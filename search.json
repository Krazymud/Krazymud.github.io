[{"title":"leetcode 115 不同的子串","url":"/2018/12/02/leetcode115/","content":"\n\n\n## 题目\n\nGiven a string **S** and a string **T**, count the number of distinct subsequences of **S** which equals **T**.\n\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `\"ACE\"` is a subsequence of `\"ABCDE\"` while `\"AEC\"` is not).\n\n**Example 1:**\n\n```\nInput: S = \"rabbbit\", T = \"rabbit\"\nOutput: 3\nExplanation:\n\nAs shown below, there are 3 ways you can generate \"rabbit\" from S.\n(The caret symbol ^ means the chosen letters)\n\nrabbbit\n^^^^ ^^\nrabbbit\n^^ ^^^^\nrabbbit\n^^^ ^^^\n```\n\n**Example 2:**\n\n```\nInput: S = \"babgbag\", T = \"bag\"\nOutput: 5\nExplanation:\n\nAs shown below, there are 5 ways you can generate \"bag\" from S.\n(The caret symbol ^ means the chosen letters)\n\nbabgbag\n^^ ^\nbabgbag\n^^    ^\nbabgbag\n^    ^^\nbabgbag\n  ^  ^^\nbabgbag\n    ^^^\n```\n\n\n\n### 解法一\n\n题目的意思是有两个字符串：s和t，要找出s中和t一样的子串数量，可以任意增减s中的元素，得到剩下的子串。\n\n一看到字符串匹配，就会想到使用动态规划算法，那么这一题的特征是什么呢？对每一个字符都有这样的选择：如果这个字符匹配了，那么就要兼顾选择了这个字符的情况（向后继续匹配），以及没有选择这个字符的情况（没有匹配，向后移一位），具体来说就是维护两个变量i和j，i对应字符串s，j对应字符串t。\n\n```pseudocode\nfunc\n设 res = 0\n若 s[i] == t[j]:\n\tres += func(i+1, j+1)\t//匹配\nres += func(i+1, j)\t\t//默认情况\n```\n\n实际实现：\n\n```c++\nint dp(int i, int j, string s, string t) {\n    if(j == t.size()) return 1;\n    if(i == s.size()) return 0;\n    int res = 0;\n    if(s[i] == t[j]){\n        res += dp(i + 1, j + 1, s, t);\n    }\n    res += dp(i + 1, j, s, t);\n    return res;\n}\n```\n\n然而，这样的算法是会超时的，原因就是它使用了递归，递归相比起来花费还是比较高。\n\n\n\n### 解法二\n\n第二种解法就不再使用递归了，而是维护一个vector，在循环中实现dp。vector的size设为字符串t的size+1，外部循环对s字符串进行遍历，内部逐步的对t中每一个字符在s中的出现次数进行累计，最后得到结果。\n\n实际实现：\n\n```c++\nint numDistinct(string s, string t) {\n    vector<int> dp(t.size() + 1, 0);\n    dp[0] = 1;\n    for(int i = 1; i <= s.size(); ++i){\n        int min_ = min(i, (int)t.size());\n        for(int j = min_; j >= 1; j--){\n            if(s[i - 1] == t[j - 1]){\n                dp[j] += dp[j - 1];\n            }\n        }\n    }\n    return dp[t.size()];\n}\n```\n\n\n\n","tags":["算法"]},{"title":"leetcode-97 Interleaving String","url":"/2018/11/14/leetcode97/","content":"\n\n\n## 题目\n\nGiven *s1*, *s2*, *s3*, find whether *s3* is formed by the interleaving of *s1* and *s2*.\n\n**Example 1:**\n\n```\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\nOutput: true\n```\n\n**Example 2:**\n\n```\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\nOutput: false\n```\n\n\n\n## 解法\n\n描述相当简略的一道题。大概意思是字符串s3可由s1与s2间的内容拼接而成，而且可以是s1、s2分成许多段来拼接，只要最后选择的字串段仍旧按照s1、s2本来的字符顺序就可以。\n\n很快能够想到这题可以使用动态规划的方法来做：子问题即每次选择字符进行拼接时选择s1或s2。那么如何来评估这个子问题呢？这里选择维护一个二维vector，假设为f。`f[i][j]`就代表已选择了s1中i个元素，s2中j个元素的情况下能否拼接成功（拼接成s3中前i+j个元素）。根据前面计算过的值来计算本次的`f[i][j]`。若两字符串s1、s2的长度分别为m、n，s3的长度为k，那么最后只需判断`f[m][n]`是否为1就行了（若m+n不等于k则一定无法拼接成功）。\n\n实际实现如下：\n\n```c++\nbool isInterleave(string s1, string s2, string s3) {\n    vector<vector<int>> dp(s1.size() + 1, vector<int>(s2.size() + 1, 0));\n    int dir[2][2] = {{-1, 0}, {0, -1}};\n    if(s1.size() + s2.size() == s3.size()){\n        dp[0][0] = 1;\n    }\n    for(int i = 0; i < dp.size(); ++i){\n        for(int j = 0; j < dp[0].size(); ++j){\n            if(i == 0 && j == 0) continue;\n            for(int m = 0; m < 2; ++m){\n                int x = i + dir[m][0], y = j + dir[m][1];\n                if(x < 0 || y < 0) continue;\n                if(dp[x][y] == 1){\n                    if(x < i && s1[i-1] == s3[i+j-1]){\n                        dp[i][j] = 1;\n                    }\n                    if(y < j && s2[j-1] == s3[i+j-1]){\n                        dp[i][j] = 1;\n                    }\n                }\n            }\n        }\n    }\n    return dp[s1.size()][s2.size()];\n}\n```\n\n","tags":["算法"]},{"title":"leetcode 32 最长括号匹配 题解","url":"/2018/11/08/leetcode32/","content":"\n\n\n## 题目\n\nGiven a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.\n\n**Example 1:**\n\n```\nInput: \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\"\n```\n\n**Example 2:**\n\n```\nInput: \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\"\n```\n\n\n\n### 解法一\n\n首先观察一下这道题目，要找到最长的满足括号匹配的字串，那么首先要想到的是，什么时候是不匹配的呢？假设有一段满足匹配的字串s，如果在它之后的第一个元素是`)`，那么这时一定不匹配，如果是`(`，则可能会向后匹配。这样一来就能够想到，使用一个栈来存储字串的下标，用一个`flag`记录上一个不匹配的元素位置（初始设为-1）。每当遇到一个`(`时，存储这个下标，如果遇到`)`，则如果此时栈为空，记录flag，否则出栈一个元素再看栈是否为空，若为空则将此时位置与flag的差值作为长度备选，否则将此时位置减去栈顶位置作为长度备选（如`(())`的情况）。\n\n实际实现：\n\n```c++\nint longestValidParentheses(string s) {\n    if(s == \"\") return 0;\n    stack<int> st;\n    int flag = -1, length = 0;\n    for(int i = 0; i < s.size(); ++i){\n        if(s[i] == '('){\n            st.push(i);\n        }\n        else{\n            if(st.empty()){\n                flag = i;\n            }\n            else{\n                st.pop();\n                if(st.empty()){\n                    length = (i - flag > length) ? i - flag : length;\n                }\n                else{\n                    length = (i - st.top() > length) ? i - st.top() : length;\n                }\n            }\n        }\n    }\n    return length;\n}\n```\n\n\n\n### 解法二\n\n第二种方法就是使用动态规划了，维护一个dp数组，只在元素为`)`时赋值（只有此时可能是一段匹配字串的结束）。注意到每遇到一对`()`，长度可以增加2，而如果遇到`))`时，此时可能匹配（即`((()))`这种情况），这时赋给dp的值就可以用到之前计算过的值了，比如此时的位置为`i`，那么就取`dp[i - 1] + dp[i - dp[i - 1] - 2] + 2`赋给`dp[i]`。\n\n具体实现：\n\n```c++\nint longestValidParentheses(string s) {\n    if(s == \"\") return 0;\n    vector<int> dp(s.size(), 0);\n    if(s[0] == '(' && s[1] == ')'){\n        dp[1] = 2;\n    }\n    for(int i = 2; i < s.size(); ++i){\n        if(s[i] == ')'){\n            if(s[i - 1] == '('){\n                dp[i] = dp[i - 2] + 2;\n            }\n            else{\n                if(i - dp[i - 1] - 1 >= 0 && s[i - dp[i - 1] - 1] == '('){\n                    if(i - dp[i - 1] - 1 == 0){\n                        dp[i] = dp[i - 1] + 2;\n                    }\n                    else{\n                        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;\n                    }\n                }\n            }\n        }\n    }\n    return *max_element(dp.begin(), dp.end());\n}\n```\n\n\n\n","tags":["算法"]},{"title":"leetcode 72+213 题解","url":"/2018/11/04/leetcode72+213/","content":"\n\n\n## 1. Edit Distance\n\nGiven two words *word1* and *word2*, find the minimum number of operations required to convert *word1* to *word2*.\n\nYou have the following 3 operations permitted on a word:\n\n1. Insert a character\n2. Delete a character\n3. Replace a character\n\n**Example 1:**\n\n```\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n```\n\n**Example 2:**\n\n```\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n```\n\n\n\n### 解法\n\n这题首先注意到，在做字符匹配时，我们一共有三种操作：插入、编辑和删除，因此可能存在非常多的对齐方式，这里使用动态规划来解决这一问题。\n\n对于动态规划来说，最重要的是定义子问题，之后就按照子问题规模递增的顺序逐个求解。那么对于这道题来说如何定义子问题呢？大目标是寻找字符串`x[1,...m]`与`y[1,...,n]`间的编辑距离，将这个问题记为`E(m, n)`，我们可以尝试找到三种操作下的最小的`E(i, j)`，其中i，j比m，n规模更小，这样逐步推导下去就可以到达底层了。也就是说对每一个`E(i, j)`，将它分解为：`E(i, j) = min{1 + E(i - 1, j), 1 + E(i, j - 1), diff(i, j) + E(i - 1, j - 1)}`，这里`diff(i, j)`在i，j相同时为0，否则为1。\n\n实现在这里没有选择递归，而是采用了填表的做法，实际效果是一样的：\n\n```c++\nint minDistance(string word1, string word2) {\n    int m = word1.size() + 1, n = word2.size() + 1;\n    vector<vector<int>> E(m, vector<int>(n, 0));\n    for(int i = 0; i < m; ++i){\n        E[i][0] = i;        \n    }\n    for(int j = 1; j < n; ++j){\n        E[0][j] = j;        \n    }\n    for(int i = 1; i < m; ++i){\n        for(int j = 1; j < n; ++j){\n            int diff = word1[i - 1] == word2[j - 1] ? 0 : 1;\n            E[i][j] = min(min(1 + E[i - 1][j], 1 + E[i][j - 1]), diff + E[i - 1][j - 1]);\n        }\n    }\n    return E[m - 1][n - 1];\n}\n```\n\n\n\n##2. House Robber Ⅱ\n\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight **without alerting the police**.\n\n**Example 1:**\n\n```\nInput: [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),\n             because they are adjacent houses.\n```\n\n**Example 2:**\n\n```\nInput: [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n             Total amount you can rob = 1 + 3 = 4.\n```\n\n\n\n### 解法\n\n题目意思即在数组中取数，相邻的数不能一起取，同时头和尾不能一起取。可以想到，当我们从前往后取时，取了一个数后下一个数的位置一定是现在的位置加2或加3，先不考虑头尾相邻，那么就可以得到我们的算法了：对数组每个位置i，填充`dp[i] += (dp[i - 2] > dp[i - 3] ? dp[i - 2] : dp[i - 3]);`，前三位则独立讨论，这样在给数组赋值的过程中就是在进行子问题的计算。最后，因为一定会到达倒数第一个位置或第二个位置，那么就返回这两个中更大的那个。\n\n对于头和尾不能同时取的问题，只需要分成不包含头和不包含尾的两部分分开求解，最后返回更大的就行了。\n\n具体实现：\n\n```c++\nint rob(vector<int>& nums) {\n    if(nums.empty()) return 0;\n    int n = nums.size(), i = 0;\n    if(nums.size() == 1){\n        return nums[0];\n    }\n    vector<int> dp1(n - 1, 0);\n    vector<int> dp2(n - 1, 0);\n    for(int j = 0; j < nums.size() - 1; ++j){\n        dp1[j] = nums[j];\n        dp2[j] = nums[j + 1];\n    }\n    return max(find(dp1), find(dp2));\n}\nint find(vector<int>& dp){\n    int i = 0;\n    if(dp.size() == 1){\n        return dp[0];\n    }\n    if(dp.size() == 2){\n        return max(dp[0], dp[1]);\n    }\n    if(dp.size() == 3){\n        return max(dp[1], dp[0] + dp[2]);\n    }\n    dp[2] += dp[0];\n    for(i = 3; i < dp.size(); ++i){\n        dp[i] += (dp[i - 2] > dp[i - 3] ? dp[i - 2] : dp[i - 3]);\n    }\n    return dp[i - 1] > dp[i - 2] ? dp[i - 1] : dp[i - 2];\n}\n```\n\n\n\n\n\n","tags":["算法"]},{"title":"leetcode-63 Unique Paths Ⅱ 题解","url":"/2018/10/27/leetcode63/","content":"\n\n\n## 题目\n\nA robot is located at the top-left corner of a *m* x *n* grid (marked 'Start' in the diagram below).\n\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\n\n![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)\n\nAn obstacle and empty space is marked as `1` and `0` respectively in the grid.\n\n**Note:** *m* and *n* will be at most 100.\n\n**Example 1:**\n\n```\nInput:\n[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\nOutput: 2\nExplanation:\nThere is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n```\n\n\n\n### 解法\n\n首先分析一下这道题，问的是从左上角走到终点即右下角总共有多少条路径，而且每次只能往右走一步或者往下走一步，如果某个位置的值为1那么就算为障碍，此时是不能走这里的。那么要计算路径的时候，可以分成对每个位置进行处理，这就成为一个DP问题了。对每一个位置来说，它最多就只有两个前置位，也就是它上方与左方的位置，如果该位置处于边界的话那么只有一个前置位。\n\n现在来讨论一下路径数目的计算，对于一个位置`(i, j)`来说，我们记录了到达它的两个前置位置`(i, j -1)`与`(i - 1, j)`的路径数，那么到达`(i, j)`的路径数就应该是两前置位置的路径数之和，这就是路径的计算方法。\n\n实现如下：\n\n```c++\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n    int m = obstacleGrid.size(), n = obstacleGrid[0].size();\n    vector<vector<int>> path(obstacleGrid.size(), vector<int>(obstacleGrid[0].size(), 0));\t//记录到达(i, j)的路径数\n    int dir[2][2] = {{-1, 0}, {0, -1}};\n    path[0][0] = obstacleGrid[0][0] == 1 ? 0 : 1;\t//起点的初始路径数\n    for(int i = 0; i < m; ++i){\n        for(int j = 0; j < n; ++j){\n            if(obstacleGrid[i][j] == 1){\n                path[i][j] = 0;\n            }\n            else{\n                for(int k = 0; k < 2; ++k){\n                    int newi = i + dir[k][0], newj = j + dir[k][1];\n                    if(newi >= 0 && newi < m && newj >= 0 && newj < n){\n                        path[i][j] += path[newi][newj];\n                    }\n                }\n            }\n        }\n    }\n    return path[m - 1][n - 1];\n}\n```\n\n","tags":["算法"]},{"title":"POW共识机制介绍","url":"/2018/10/21/pow/","content":"\n\n\nPoW，即Proof-of-Work，工作量证明，本质上是一种经济手段，它要求请求资源方提供一些“工作”来证明它没有恶意，因为这些工作需要花费一定的资源（时间或金钱），所以可以用来解决如ddos攻击、垃圾信息等问题。相应地，这些工作必须有如下特点：对于资源请求方来说难于立即解决（不过是可解的），但对于资源提供方来说是容易验证的。\n\n对于比特币来说，它使用的是一种叫hashcash（哈希现金）的工作量证明，它最初被用于做邮件过滤，对于正常的邮件来说，因为一般来说短时间内发送量不会很高，相应的工作量证明也不会占用很多时间。但对于垃圾邮件来说，因为需要发送的量很大，占用的计算资源也就很大，这样做是得不偿失的，所以也就能够过滤掉垃圾邮件。\n\n在比特币中，hashcash则是用来产生区块的。在一个区块被添加至链上之前，矿工必须完成工作量证明。这里又存在一个问题，矿工为什么会想要去完成工作量证明呢（耗费计算资源）？这是因为产生区块的过程实际上是在记账，是把交易记录、时间、账本序号、上一个区块的hash值一起hash打包的过程，而对于记账成功的矿工是提供比特币奖励的，这就激发了矿工争相记账，但最后能够完成工作量证明成功记帐的矿工只有一个。\n\n矿工在进行工作量证明之前，要做如下工作：\n\n- 收集广播中还没有被记录的交易信息\n- 检查每个交易信息中付款地址的余额信息\n- 检查交易签名\n- 打包验证通过的交易信息\n- 添加一个奖励交易（新区快的首个交易）：给自己的地址增加12.5个比特币（奖励）\n\n之后就开始进行工作量证明（散列算法一般选择SHA256）：\n\n1. 把上个块的hash值与当前帐页信息一起进行hash处理\n2. 设置一个随机值nonce\n3. nonce递增，并对nonce，和第一步得到的字符串一起做hash，得到满足前置0个数的结果，就是正确的nonce\n\n可见“工作”就是找到随机数的过程，当然这个工作的难度会根据区块产生的速度自动调节，一般是10分钟左右诞生一区块，难度调节则是通过设置前置0的个数。当一个矿工成功完成工作后，就会广播发布区块，收到区块的网络节点进行验证，验证通过则不再竞争，而是再此区块后进行工作。如果同时收到多个区块，则先在最先收到的区块后进行工作，保留其余收到的区块，若后续发现另一条链更长则更换区块。\n\n从上述过程我们可以发现POW机制的优缺点都比较显著：\n\n优点：\n\n- 去中心化，做的工作越多，得到的越多，而且相对公平，即使算力更大也只是获得收益的概率变大，难以达到垄断。\n- 安全性高，理论上来说要做attacker必须具有压倒性的算力优势（>50%），而且对于一般attacker来说，诚实挖矿的收益还更高，所以一般不会出现欺诈的现象。\n\n缺点：\n\n- 资源浪费。目前比特币的价格十分高昂，吸引了越来越多的人投入这一领域。大批矿池、矿机进行军备竞赛，加快挖矿的速度。但因为比特币系统的调节，新区块产生的速度越快，计算问题的难度就会更大，以至于形成了恶性循环，许多计算资源就这样浪费掉了。\n- 交易确认时间过长。随着节点的增加，区块链更容易产生分叉，选择最长的主链后其他的分支都要舍弃。目前区块确认的共识周期长达十分钟，每秒交易量也很低。\n\n对于资源浪费这一点，可以引入一些更有价值的问题，如寻找大的素数等数学、物理乃至其他学科上的计算问题，而不只是单纯进行hash值寻找。但实际上，要完成这一点还是很难的，因为这些问题可能相对难以快速验证，也没有好的方法去控制问题难度。\n\n对于POW的缺点，另一种共识机制：POS（Proof of stake）提供了很好的解决方案：\n\n- 不需要消耗庞大的算力，节省电力：如在BFT-style的POS中，不再根据计算工作来证明自己，而是每个人都被随机的选择去创建块，但块的确认是通过多轮的投票来决定的，这就避免了资源消耗。\n- POS机制会对节点持币以及维持节点给予少量的奖励，然而恶意交易所受到的惩罚会千百倍于奖励，这就防止了持币多的人进行恶意操作，防止中心化。\n\n当然，POS也存在自己的缺点，以至于近来还出现了POW-POS混合机制。想必在不远的未来，区块链共识机制会更加的成熟，更加的稳定。","tags":["区块链"]},{"title":"leetcode 55 题解","url":"/2018/10/16/leetcode55/","content":"\n\n\n## 题目：\n\n**Jump Game**\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\n\nEach element in the array represents your maximum jump length at that position.\n\nDetermine if you are able to reach the last index.\n\n**Example 1:**\n\n```\nInput: [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n**Example 2:**\n\n```\nInput: [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum\n             jump length is 0, which makes it impossible to reach the last index.\n```\n\n\n\n### 题解：\n\n这是一道标明为Greedy类型的题目，可以用贪心算法来解，问题就在于如何判断对这道题目来说何为“局部最优解”。\n\n这道题的意思是从下标为0的位置开始，每个位置上有这次可以跳跃的最长距离，问能否达到终点。一开始我想到的方法是找此次跳跃距离覆盖的位置中跳跃距离最长的位置，但这个方法是错误的，当输入为`[4 2 0 0 1 1 4 4 4 0 4 0]`时，它在判断第一步跳到哪里的时候会选择位置1（元素2）而不是位置4（元素1），这就导致了当它从新的位置进行跳跃时，其后两个元素都为0，于是就判断无法达到终点了，然而实际是可以的。\n\n从上述例子可以发现，尽管1小于2，但它所能达到的位置与终点的距离比2更近，所以在这道题中局部最优应该是选择能够达到的位置距离终点最短的元素作为此次跳跃的目的地。代码实现如下：\n\n```c++\nbool canJump(vector<int>& nums) {\n    int size = nums.size();\n    if(nums.size() == 1) return true;\n    for(int i = 0; i < size; i++){\n        if(nums[i] == 0){\n            return false;\n        }\n        int min = size - nums[i + 1] - i - 1, pos = i + 1;\n        for(int j = i + 1; j <= i + nums[i]; j++){\n            if(j == size - 1){\n                return true;\n            }\n            pos = (size - nums[j] - j) <= min ? j : pos;\n            min = (size - nums[j] - j) <= min ? size - nums[j] - j : min;\n        }\n        i = pos - 1;\n    }\n}\n```\n\n\n\n### 升级\n\n做完这道题后我发现了一道名为**Jump Game Ⅱ**的题目，原来是这道题的升级版，要求不仅给出判断能否达到终点，还要给出跳跃的步数。因为实际上我们刚才找到的就是最短的路径了，所以只需要稍微修改一下代码就行：\n\n```c++\nint jump(vector<int>& nums) {\n    int count = 0;\n    int size = nums.size();\n    if(nums.size() == 1) return 0;\n    for(int i = 0; i < size; i++){\n        count++;\n        if(nums[i] == 0){\n            return false;\n        }\n        int min = size - nums[i + 1] - i - 1, pos = i + 1;\n        for(int j = i + 1; j <= i + nums[i]; j++){\n            if(j == size - 1){\n                return count;\n            }\n            pos = (size - nums[j] - j) <= min ? j : pos;\n            min = (size - nums[j] - j) <= min ? size - nums[j] - j : min;\n        }\n        i = pos - 1;\n    }\n}\n```\n\n\n\n\n\n\n\n","tags":["算法"]},{"title":"Go语言实现Selpg","url":"/2018/10/11/selpg/","content":"\n\n\n实现：[github](https://github.com/Krazymud/firstgo/tree/master/selpg)\n\n\n## 前言\n\n本文介绍了使用GO语言实现Selpg这样一个程序的过程，总体参考了[开发Linux命令行实用程序](https://www.ibm.com/developerworks/cn/linux/shell/clutil/index.html)这篇文章，它讲的是使用C语言实现Selpg。Selpg即Select Pages，允许用户指定从输入文本（可来自文件或命令行或是另一个进程的输出）抽取的页的范围，并控制输出的位置，可以是标准输出，也可以输入至文件或子进程。\n\n\n\n## Usage\n\n```shell\nUsage: selpg [-s startPage] [-e endPage] [-l linesPerPage | -f] [-d printDest] filename\n\nOptions:\n  -d, --dest string\t\t(Optional) Enter printing destination\n  -e, --endPage int\t\t(Mandatory) Input Your endPage\n  -f, --pageBreak\t\t(Optional) Choosing pageBreaks mode\n  -l, --pageLen int     (Optional) Choosing pageLen mode, enter pageLen\n  -s, --startPage int\t(Mandatory) Input Your startPage\n```\n\n\n\n## 代码结构\n\n总共有三个函数：\n\n1. main函数：解析命令参数的入口函数\n\n2. processArgs函数：处理参数，进行错误处理\n\n3. processInput函数：经过processArgs函数后，这里根据命令进行（文件）操作\n\n除此之外，还有保存参数的struct：selpgArgs，以及五个解析参数用的flag。\n\nselpgArgs存储内容：\n\n```go\ntype selpgArgs struct {\n\tstartPage, endPage, pageLen, pageType int\n\tinFilename                            string\n\tprintDest                             string\n}\n```\n\n\n\n## 关键实现\n\n- pflag\n\n在前面的参考文章中，可以看到如果使用C语言来解析参数，代码实现还是比较繁杂的，需要手动进行参数的获取、判断乃至解析。而在Go语言中，有很多便利的包供我们使用，在这里使用的是pflag这个包来进行参数的解析。\n\npflag包的使用是非常简单的，首先`go get`了这个包([spf13/pflag](https://github.com/spf13/pflag))之后，引入它就可以使用了。基本的参数绑定操作：\n\n```go\nvar ip *int = flag.Int(\"flagname\", 1234, \"help message for flagname\")\t//绑定\"--flagname\"的值到*ip上，格式为int\n//或\nvar flagvar int\t\t//声明\nfunc init() {\n    flag.IntVar(&flagvar, \"flagname\", 1234, \"help message for flagname\")\t//绑定\n}\n```\n\n在Selpg中，我们需要两种格式的参数，拿输入文本的起始页做例子，我们就需要同时接受`--startPage`与`-s`这两种输入，pflag也允许我们这样做：\n\n```go\nvar inputS = flag.IntP(\"startPage\", \"s\", -1, \"...\")\n//startPage配合\"--\"使用，s配合\"-\"使用\n```\n\n最后，`flag.Parse()`自动进行参数的捕获、解析。如果是没有带`-`或`--`的参数，则可通过`flag.Args()`获取，这类参数的数量为`flag.Narg()`。\n\n\n\n- bufio\n\n在Selpg的实现中我使用了bufio包来进行输入输出的定向，bufio即buffered I/O，它封装了io.Reader与io.Writer，使用起来还是较为方便的。\n\n读取输入部分：\n\n```go\n//从命令行输入\ninputReader = bufio.NewReader(os.Stdin) \n//或打开一个文件后输入\nfile, err = os.Open(selpg.inFilename)\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(1)\n\t}\ninputReader = bufio.NewReader(file)\t\n//读取输入，直到某一字符（包含此字符）\nline, err = inputReader.ReadBytes('\\n')\t//换页为行模式\nline, err = inputReader.ReadBytes('\\f')\t//换页为换页符模式\n```\n\n定向输出部分：\n\n```go\noutputWriter = bufio.NewWriter(os.Stdout)\noutputWriter.Write(line)\noutputWriter.Flush()\t//这一步必须\n```\n\n\n\n- os/exec\n\n\"-dXXX\"的实现可能是比较难的一部分，这里通过os/exec包来实现，exec允许运行外部命令，它封装了os.StartProcess，故我们可以更容易地重定向输入输出，可通过管道向命令输入内容。\n\n当`-d`参数获得了一个打印机地址，就进行如下操作：\n\n```go\n//初始化外部命令\ncmd = exec.Command(\"lp\", \"-d\", selpg.printDest)\t\n//建立一个管道以输入打印内容\nstdin, err = cmd.StdinPipe()\n//写入管道\n_, err := io.WriteString(stdin, string(line))\n//关闭管道、获得输出\nstdin.Close()\nstderr, _ := cmd.CombinedOutput()\n```\n\n注意`cmd.CombinedOutput()`的作用是运行命令并获得组合在一起的stdout/stderr输出。\n\n\n\n## 简单测试\n\n- `selpg -s1 -e1`\n\n即，从命令行输入，并输出到命令行，打印前72行（default）\n\n![1](selpg/1.png)\n\n- `selpg -s1 -e1 -l3 input`\n\n即，从文件输入，并输出到命令行，打印前三行\n\n![2](selpg/2.png)\n\n- `selpg -s1 -e input >output 2>error`\n\n即，正确输出到文件output，错误输出至文件error（故意写成错误命令）\n\n![3](selpg/3.png)\n\n- 测试换页符，首先建立包含换页符的文件：\n\n![4](selpg/4.png)\n\n接着，测试`selpg -s1 -e3 -f input`\n\n![5](selpg/5.png)\n\n- 测试输出至打印机lp1\n\n![6](selpg/6.png)\n\n命令正确执行了，只是没有打印机\n\n- `selpg -s1 -e20 -l20 test.txt | grep -n \"Geralt\"`\n\n测试读取并输出长篇小说的前20页（设置每页长20行）\n\n![Geralt](selpg/7.png)\n\n\n\n这样就实现了selpg程序。","tags":["服务计算"]},{"title":"leetcode 841 KeysAndRooms 题解","url":"/2018/10/11/leetcode841/","content":"\n\n\n## 题目\n\nThere are `N` rooms and you start in room `0`.  Each room has a distinct number in `0, 1, 2, ..., N-1`, and each room may have some keys to access the next room. \n\nFormally, each room `i` has a list of keys `rooms[i]`, and each key `rooms[i][j]` is an integer in `[0, 1, ..., N-1]`where `N = rooms.length`.  A key `rooms[i][j] = v` opens the room with number `v`.\n\nInitially, all the rooms start locked (except for room `0`). \n\nYou can walk back and forth between rooms freely.\n\nReturn `true` if and only if you can enter every room.\n\n\n\n**Example 1:**\n\n```\nInput: [[1],[2],[3],[]]\nOutput: true\nExplanation:  \nWe start in room 0, and pick up key 1.\nWe then go to room 1, and pick up key 2.\nWe then go to room 2, and pick up key 3.\nWe then go to room 3.  Since we were able to go to every room, we return true.\n```\n\n**Example 2:**\n\n```\nInput: [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We can't enter the room with number 2.\n```\n\n**Note:**\n\n1. `1 <= rooms.length <= 1000`\n2. `0 <= rooms[i].length <= 1000`\n3. The number of keys in all rooms combined is at most `3000`.\n\n\n\n### 解法\n\n总的来说，就是数组的每个位是一个房间，房间中存有通往其他房间的钥匙，从0号房间开始，问是否能走完全部房间。于是马上想到了BFS算法，只要最后所有位置都visit过，就能够走完所有房间。\n\n代码如下：\n\n```c++\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\n    vector<int> visited(rooms.size(), 0);\t//已到过的房间\n    queue<int> tovisit;\t\t//将要去的房间\n    tovisit.push(0);\n    visited[0] = 1;\n    while(!tovisit.empty()){\n        int curr = tovisit.front();\n        tovisit.pop();\n        for(auto r : rooms[curr]){\n            if(!visited[r]){\n                tovisit.push(r);\n                visited[r] = 1;\n            }\n        }\n    }\n    for(int i = 0; i < rooms.size(); i++){\n        if(!visited[i]){\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n","tags":["算法"]},{"title":"leetcode 877 Stone Game 题解","url":"/2018/10/06/leetcode877/","content":"\n\n\n国庆长假，水一题\n\n\n## 题目\n\nAlex and Lee play a game with piles of stones.  There are an even number of piles **arranged in a row**, and each pile has a positive integer number of stones `piles[i]`.\n\nThe objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.\n\nAlex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins.\n\nAssuming Alex and Lee play optimally, return `True` if and only if Alex wins the game.\n\n \n\n**Example 1:**\n\n```\nInput: [5,3,4,5]\nOutput: true\nExplanation: \nAlex starts first, and can only take the first 5 or the last 5.\nSay he takes the first 5, so that the row becomes [3, 4, 5].\nIf Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.\nIf Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alex, so we return true.\n```\n\n \n\n**Note:**\n\n1. `2 <= piles.length <= 500`\n2. `piles.length` is even.\n3. `1 <= piles[i] <= 500`\n4. `sum(piles)` is odd.\n\n\n\n### 解法一\n\n第一种解法是使用动态规划，注意到每次Alex和Lee的操作都是从piles的头或尾取走一个最大的数，那么就可以把问题分解到多个子问题上分别来解决。\n\n先构建一个数组存储piles的备份，以及一个二维数组存储各个子问题的解：\n\n```c++\nvector<vector<int>> dparr;\nvector<int> p;\nbool stoneGame(vector<int>& piles) {\n    p = piles;\n    int size = piles.size();\n    vector<vector<int>> tmp(size, vector<int>(size, 0));\n    dparr = tmp;\n    return dp(0, size - 1) > 0;\n}\n```\n\n下面是dp的具体实现，这里将Lee的操作视为从Alex的得分中扣除，最后只要Alex的得分大于零则Alex胜利：\n\n```c++\nint dp(int low, int high){\n    if(low == high){\n        return 0;\n    }\n    if(dparr[low][high] != 0){\t//避免重复计算\n        return dparr[low][high];\n    }\n    int res = 0;\n    if((high - low + 1) % 2 == 0){  //Alex\n        res = max(dp(low + 1, high) + p[low], dp(low, high - 1) + p[high]);\n    } \n    else{\t//Lee\n        res = min(dp(low + 1, high) - p[low], dp(low, high - 1) - p[high]);\n    }\n    dparr[low][high] = res;\n    return res;\n}\n```\n\n\n\n### 解法二\n\n让我们回到问题：数组中一共有偶数个元素，Alex先选，Lee后选。那么假设数组有2n个元素，如果Alex第一次选择了元素1，则Lee可以选择2或2n，在之后Alex可以选择3、2n或者2、2n-1，以此类推。也就是说，可以保证Alex一定能够选到所有奇数位置的元素或是所有偶数位置的元素，那么只要一开始知道奇数位置元素之和与偶数位置元素之和哪个更大，就能保证Alex胜利，所以实际上这道题我们只需要：\n\n```c++\nreturn true;\n```\n\n就能够通过。\n\n\n\n","tags":["算法"]},{"title":"leetcode 847 访问所有节点的最短路径 题解","url":"/2018/09/27/leetcode847/","content":"\n\n\n## 题目\n\nAn undirected, connected graph of N nodes (labeled `0, 1, 2, ..., N-1`) is given as `graph`.\n\n`graph.length = N`, and `j != i` is in the list `graph[i]` exactly once, if and only if nodes `i` and `j` are connected.\n\nReturn the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.\n\n \n\n**Example 1:**\n\n```\nInput: [[1,2,3],[0],[0],[0]]\nOutput: 4\nExplanation: One possible path is [1,0,2,0,3]\n```\n\n**Example 2:**\n\n```\nInput: [[1],[0,2,4],[1,3,4],[2],[1,2]]\nOutput: 4\nExplanation: One possible path is [0,1,4,2,3]\n```\n\n \n\n**Note:**\n\n1. `1 <= graph.length <= 12`\n2. `0 <= graph[i].length < graph.length`\n\n\n\n### 解法一\n\n这周刚好学到了BFS、Dijkstra、Bellman–Ford等处理图论问题的算法，这里就能够用上了。这一题是要在无向图中找到经过了每一个节点的最短路径，可以很快想到可以用BFS算法，但是再一想，BFS算法可以用来找两点间最短路径，而这里并没有给出起点和终点，只是单纯的找到一条经过每个节点的最短路径，怎么办呢？\n\n以往使用BFS算法时，是将节点不断加入、弹出队列，在这里我们可以换种思路，比如把从各个节点开始的路径加入、更新、弹出队列，并记录此时路径对应的长度，直到队列为空时，此时经过了所有节点的路径的长度应该被更新了许多次，达到了最小。\n\n首先需要构建一个struct类型，代表此时的路径状态：\n\n```c++\nstruct state{\n    int visited, tovisit;\t//已经过的节点，要访问的节点\n    state(int v, int t){\n        visited = v;\n        tovisit = t;\n    }\n};\n```\n\n用bits来记录经过的节点：从第n号节点开始即为`1 << n = 1...00`（n个0），访问完所有节点的路径状态应该是`011..1`，哪一位为1即代表经过了哪一位，访问节点的邻居后的节点状态这样表示：`visited | (1 << neighbour)`。\n\n接下来是实现：\n\n```c++\nint shortestPathLength(vector<vector<int>>& graph) {\n    int n = graph.size();\n    queue<state> mqueue;\n    vector<vector<int>> dist(1 << n, vector<int>(n, n * n));\n    for(int i = 0; i < n; i++){\n        mqueue.push(state(1 << i, i));\t//queue中一开始设置各个节点开始的初始路径\n        dist[1 << i][i] = 0;\n    }\n    while(!mqueue.empty()){\n        state node = mqueue.front();\n        mqueue.pop();\n        int dis = dist[node.visited][node.tovisit];\n        if(node.visited == (1 << n) - 1) return dis;\n        for(int neighbour : graph[node.tovisit]){\t//通过graph访问节点邻居\n            int visited2 = node.visited | (1 << neighbour);\n            if(dis + 1 < dist[visited2][neighbour]){\t//路径更短则更新\n                dist[visited2][neighbour] = dis + 1;\n                mqueue.push(state(visited2, neighbour));\t//更新后的路径状态再加入queue\n            }\n        }\n    }\n}\n```\n\n比较难想到的地方就是对路径状态进行BFS。\n\n\n\n### 解法二\n\n通过官方solution发现了第二种使用了Dynamic Programming的解法，大体上其实和BFS差不多，都是对路径状态进行操作。\n\n解法如下：\n\n```c++\nint shortestPathLength(vector<vector<int>>& graph) {\n    int n = graph.size();\n    vector<vector<int>> dist(1 << n, vector<int>(n, n * n));\n    for(int i = 0; i < n; i++){\n        dist[1 << i][i] = 0;\n    }\n    for(int visited = 0; visited < 1 << n; ++visited){\n        bool repeat = true;\n        while(repeat){\n            repeat = false;\n            for(int tovisit = 0; tovisit < n; ++tovisit){\n                int dis = dist[visited][tovisit];\n                for(int neighbour : graph[tovisit]){\n                    int visited2 = visited | (1 << neighbour);\n                    if(dis + 1 < dist[visited2][neighbour]){\n                        dist[visited2][neighbour] = dis + 1;\n                        if(visited2 == visited) repeat = true;\n                    }\n                }\n            }\n        }\n    }\n    int ans = n * n;\n    for(int i : dist[(1 << n) - 1]){\n        ans = min(i, ans);\n    }\n    return ans;\n}\n```\n\n可以看到，这种解法是通过多重循环，对dist中每一种路径状态进行更新，最后取都是经过每个节点的路径中最短的一条。\n\n\n\n\n\n","tags":["算法"]},{"title":"CentOS下GO开发环境安装与配置","url":"/2018/09/26/go-env/","content":"\n\n\n## 前情提要\n\n在[Win10环境下安装配置VirtualBox，搭建CentOS私有云](https://krazymud.github.io/2018/09/09/vbox-cfg/)一节中我们已经成功的配置好了虚拟机上的CentOS私有云，今天就来研究一下GO的开发环境的安装与配置。\n\n\n\n## 安装、配置步骤\n\n### 1. 安装golang\n\n可以选择在[官方下载页](https://golang.org/dl/)处找到最新的版本来下载安装，这里省事起见选择了直接用系统包管理工具安装：\n\n```shell\n# sudo yum install golang\n```\n\n安装完后调用`go version`命令查看版本号，这里安装的是go 1.9.4\n\n查看go都安装在了哪里：\n\n```shell\n# rpm -ql golang\n```\n\n\n\n### 2. 配置golang环境\n\ngo工具为公共代码仓库中维护的开源代码而设计，用go所编写的代码必须放在**工作空间**内，它包含三个子目录：\n\n- src目录包含Go的源文件，它们被组织成包（一个目录对应一个包），是运行`go install`、`go run`等命令时的当前路径\n- pkg目录包含包对象（golang编译的.a中间文件）\n- bin目录包含可执行文件\n\n创建工作空间目录并设置GOPATH：\n\n```shell\n# mkdir $HOME/gowork\n# export GOPATH=$HOME/work\n```\n\n并将工作空间中的bin目录添加到PATH中，以便以后直接运行安装的go程序：\n\n```shell\n# export PATH=$PATH:$GOPATH/bin\n```\n\n最后使这些配置生效：\n\n```shell\n# source $HOME/.profile\n```\n\n检查配置可以通过：\n\n```shell\n# go env\n```\n\n\n\n### 3. 安装vscode编辑器与其他\n\n**vscode安装**\n\n在开始愉快的用go玩耍前还需要安装一款适合你的编辑器，这里选择的是vscode，巨硬大法好嘛。\n\n在[官方教程](https://code.visualstudio.com/docs/setup)中有展示各个平台的安装流程，在CentOS平台上的安装命令：\n\n```shell\n# sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc\n# sudo sh -c 'echo -e \"[code]\\nname=Visual Studio Code\\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\" > /etc/yum.repos.d/vscode.repo'\n# yum check-update\t//检查更新\n# sudo yum install code\n```\n\n**git安装**\n\n打开vscode后如果你没有安装git那么它会提醒你安装，如果你之前使用`yum`命令安装过的话它会提醒你版本太老（CentOS下），所以这里选择手动安装最新版本的git。\n\n首先安装一些后续需要的依赖包：\n\n```shell\n# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel\n# yum install  gcc perl-ExtUtils-MakeMaker\n```\n\n接着如果之前有装过旧版本的话需要卸载：\n\n```shell\n# yum remove git\n```\n\n然后wget下载官方最新版本：\n\n```shell\n# wget https://www.kernel.org/pub/software/scm/git/git-2.9.2.tar.gz\n# tar -zxvf git-2.9.2.tar.gz\n```\n\n最后，编译安装，配置环境：\n\n```shell\n# cd git-2.9.2\n# make prefix=/usr/local/git all\n# make prefix=/usr/local/git install\n# echo \"export PATH=$PATH:/usr/local/git/bin\" >> /etc/bashrc\n# source /etc/bashrc\n```\n\n如果安装出错，应该是还有什么依赖没有安装好，根据提示手动安装就可以。\n\n检查git版本：\n\n```shell\n# git version\ngit version 2.9.2\n```\n\n**注意：如果安装完查看版本不是我们安装的最新版，请重新执行下面的操作**\n\n```shell\n# yum remove -y git\n# source /etc/bashrc\n# git --version\n```\n\n**工具包安装**\n\n现在总能够开始写go了吧？在vscode创建一个hello.go刚写了条package就发现又报错了，原来是很多golang的tools没有安装，根据vscode的提示一键安装，然而[golang.org](https://golang.org)并不能连上，于是，这一步也要我们手动安装。\n\n首先在go工作空间的src目录下建立一个golang.org文件夹，在其中再建立一个x文件夹，cd切换到x文件夹下，下载插件包：\n\n```shell\n# git clone https://github.com/golang/tools.git tools\n# git clone https://github.com/golang/lint.git lint\n```\n\n执行完毕后，在x文件夹下会多两个文件夹tools和lint。\n\n最后执行安装命令，安装在vscode中没有安装的工具包，例如：\n\n```shell\n# go install golang.org/x/tools/cmd/guru\n# go install golang.org/x/tools/cmd/gorename\n# go install golang.org/x/tools/cmd/gorename\n# go install golang.org\\x\\lint\\golint\n...\n```\n\n配置成功！接下来可以使用vs code创建hello.go测试一下：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Printf(\"hello, world\\n\")\n}\n```\n\n在终端运行！\n\n```shell\n# go run hello.go\nhello, world\n```\n\n\n\n### 4. 绑定远程仓库\n\n现在你的go工作空间的架构应该类似这样：\n\n```shell\nbin/\n\t...                         # 可执行命令\npkg/\n\tlinux_amd64/\n\t\t...\t\t\t\t\t\t# 包对象\nsrc/\t\t\t\t\t\t\t#源码\n\tgithub.com/\n\t\t...\n\tgolang.org/\n\t\t...\n```\n\n此时需要在github.com文件夹下创建一个和你自己github账号名称一样的文件夹，这个文件夹作为以后与远程库同步的存放go代码的文件夹，在这个文件夹下可以创建各种包。\n\n在你的github账号上手动创建一个远程库，之后根据提示，在本地文件夹中：\n\n```shell\n# echo \"# xxx\" >> README.md\n# git init\n# git add README.md\n# git commit -m \"first commit\"\n# git remote add origin https://github.com/username/xxx.git\n# git push -u origin master\n```\n\n之后每次git add、commit后要push时，都要输入自己的账号、密码来操作。当然也可以选择用git ssh，这里就不介绍了。\n\n\n\n\n\n\n\n","tags":["服务计算"]},{"title":"初步认识区块链","url":"/2018/09/22/blockchain/","content":"\n\n\n自中本聪在2008年于《比特币白皮书》中提出“区块链”概念，并在2009年开发第一个区块即“创世区块”起，十年的时间过去了。在这十年的时间中，区块链技术已有长足的发展，开始初步的进入应用领域、大众视野。而同时，它也面临着许多挑战，这些挑战亟待更多的人来研究、解决。\n\t\n区块链是借由密码学串接并保护内容的串联交易记录（区块），每个区块包含着前一个区块的加密散列、相应时间戳以及交易数据。它的优点都基于其去中心化的特点，得以在节点无需互相信任的分布式系统中实现基于去中心化信用的点对点交易、协调与协作。举例来说，在现有的中心化信用系统中，交易行为都要通过某个中心化的机构来认证，而在区块链中，认证不是由某一个中心机构进行的，而是记录在每个节点上，是透明化、可追溯的。这样就为解决中心化机构普遍存在的高成本、低效率以及数据存储不安全等问题提供了解决方案。\n\n在优点之外，区块链也面临着许多问题与挑战，这里介绍其中的一部分：\n\n1. 人才匮乏。目前来说，尽管相应的技术与产业发展的很快，但相关学术研究严重滞后。技术创新缺乏理论支持必然走不远，所以相关领域亟待学术跟进。\n2. 监管问题。以区块链这种去中心化技术搭建的交易平台，在交易过程中，参与者的身份都是匿名的，这就和传统的交易平台完全不同了，传统的监管方式也无法再使用。因此，目前比特币的交易市场中充斥着洗钱、黑市交易的犯罪活动，这些行为如何监管也是需要在未来解决的问题。\n3. 安全问题，这也是区块链迄今为止面临的最重要的问题，如基于PoW共识过程的区块链面临的51%攻击问题，和基于PoS共识过程的区块链面临的N@S攻击问题，更为安全有效的共识机制还需要人们的研究和设计。\n4. 效率。目前完全同步自创世区块至今的区块数据需要大于60gb的存储空间，而这个数字还在持续增加中，即使是部分节点采用轻量化方案，还是不能完全解决此问题。同时，区块链的交易效率非常低，比特币区块链目前每秒仅能处理七笔交易，这就限制了区块链在大多数金融系统高额交易场景中的应用。最后，它的交易确认时间一般为十分钟左右（区块的生成时间），这在小额交易和时间敏感交易中是不可忍受的。\n\n区块链的技术应用可分为三个阶段：\n\n- 区块链1.0模式：以可编程数字加密货币体系为主要特征。加密货币以比特币、莱特币为代表，具有支付、流通的货币职能。\n- 区块链2.0模式：以可编程金融系统为主要特征。是对金融领域的使用场景和流程进行梳理、优化的应用阶段，以以太坊、瑞波币等为代表的智能合约在这一阶段。\n- 区块链3.0模式：以可编程社会为主要特征，是区块链技术在社会各个领域下的应用场景实现。\n\n需要注意的是，这三个模式并不是演进式发展的，而是并行发展的，在区块链2.0乃至3.0已开始发展的背景下，区块链1.0模式的数字加密货币体系实际上仍远未成熟，还有很长的路要走。\n\n目前部分区块链的项目已初步有了一些简单的应用场景，如通过以太坊网络、BTS平台等发行一些基于区块链技术的项目，但是数量还远远不够，覆盖的应用方向也很少。可以说人们通过比特币认识了区块链，但是区块链技术不仅能够应用于数字加密货币领域，它在数据存储、鉴证，金融交易，资产管理和选举投票等方面都有广大的应用前景。总的来说，区块链技术目前还在积累阶段，它的潜力是巨大的，也许，在未来它不仅能改变我们的交易方式，还能深入的影响我们社会的方方面面，甚至，改变整个社会。","tags":["区块链"]},{"title":"leetcode 765+778 题解","url":"/2018/09/19/leetcode765+778/","content":"\n\n\n这周因为两道题目都只想到了一种解法，所以写在一起。\n\n\n\n## 1. Swim In Rising Water\n\nOn an N x N `grid`, each square `grid[i][j]` represents the elevation at that point `(i,j)`.\n\nNow rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\nYou start at the top left square `(0, 0)`. What is the least time until you can reach the bottom right square `(N-1, N-1)`?\n\n**Example 1:**\n\n```\nInput: [[0,2],[1,3]]\nOutput: 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\n\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n```\n\n**Example 2:**\n\n```\nInput: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\nOutput: 16\nExplanation:\n 0  1  2  3  4\n24 23 22 21  5\n12 13 14 15 16\n11 17 18 19 20\n10  9  8  7  6\n\nThe final route is marked in bold.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n```\n\n**Note:**\n\n1. `2 <= N <= 50`.\n2. grid[i][j] is a permutation of [0, ..., N*N - 1].\n\n\n\n### 解法\n\n这道题的意思是，在t时刻，海拔为t，而n*n的二维矩阵的每个数值都代表了一处的海拔，从一点游到另一点的条件是两处的海拔（值）都大于等于t，要求求出从（0，0）到（n-1，n-1）的最小时间。也就是一个搜索节点的问题，可以用bfs即广度优先搜索的思路来做。\n\n在寻找足够大的t时，我用二分法来实现，这样又可以节约不少时间：\n\n```c++\nint swimInWater(vector<vector<int>>& grid) {\n    int n = grid.size(), st = grid[0][0], ed = n * n - 1, t = 0;\n    while(st < ed){\n        t = (st + ed) / 2;\n        if(swim(grid, t)){\t//判断t时能否到达终点\n            ed = t;\n        }\n        else st = t + (st + ed) % 2;\n    }\n    return st;\n}\n```\n\n真正的实现函数里，bfs用一个queue来实现，还要一个二维vector来记录已经到过的节点。然后就是每次把和节点相邻的未经过的节点（且是数值小于等于t的）加入bfs，并把现有节点pop出去，看能否在bfs为空之前找到终点。\n\n```c++\nbool swim(vector<vector<int>>& grid, int t){\n    int n = grid.size();\n    queue<pair<int, int>> bfs;\n    vector<vector<int>> visited(n, vector<int>(n));\n    int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\t//右左下上\n    bfs.emplace(0, 0);\n    visited[0][0] = 1;\n    while(bfs.size()){\n        int x = bfs.front().first, y = bfs.front().second;\n        bfs.pop();\n        if(grid[x][y] <= t){\n            if(x == n - 1 && y == n - 1) return true;\n            for(auto d : dir){\n                int xs = x + d[0], ys = y + d[1];\n                if(xs >= 0 && xs < n && ys >= 0 && ys < n && !visited[xs][ys]){\t//判断边界\n                    visited[xs][ys] = 1;\n                    bfs.emplace(xs, ys);\n                }\n            }\n        }\n    }\n    return false;\n}\n```\n\n这样就完成了这一道题。\n\n\n\n## 2. Couples Holding Hands\n\nN couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A *swap* consists of choosing **any** two people, then they stand up and switch seats.\n\nThe people and seats are represented by an integer from `0` to `2N-1`, the couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2N-2, 2N-1)`.\n\nThe couples' initial seating is given by `row[i]` being the value of the person who is initially sitting in the i-th seat.\n\n**Example 1:**\n\n```\nInput: row = [0, 2, 1, 3]\nOutput: 1\nExplanation: We only need to swap the second (row[1]) and third (row[2]) person.\n```\n\n\n\n**Example 2:**\n\n```\nInput: row = [3, 2, 0, 1]\nOutput: 0\nExplanation: All couples are already seated side by side.\n```\n\n\n\n**Note:**\n\n1. `len(row)` is even and in the range of `[4, 60]`.\n2. `row` is guaranteed to be a permutation of `0...len(row)-1`.\n\n\n\n### 解法（伪）\n\n在这道题目中，有许多对couple，他们是(0, 1), (2, 3), ..., (2n-2, 2n-1)。现在它们的顺序被打乱了，而你可以随即调换元素的位置，你需要找到调换次数最少的方案。\n\n我的做法是简单的在判断两个元素不是一对couple后，往后查找它的couple并替换，同时调换次数增加一次。\n\n```c++\nint minSwapsCouples(vector<int>& row) {\n    int swap = 0;\n    for(int i = 0; i < row.size() - 1; i += 2){\n        if(row[i] % 2){\n            if(row[i + 1] != row[i] - 1){\n                swap++;\n                for(int j = i + 2; j < row.size(); j++){\n                    if(row[j] == row[i] - 1){\n                        int temp = row[j];\n                        row[j] = row[i + 1];\n                        row[i + 1] = temp;\n                        break;\n                    }\n                }\n            }\n        }\n        else{\n            if(row[i + 1] != row[i] + 1){\n                swap++;\n                for(int j = i + 2; j < row.size(); j++){\n                    if(row[j] == row[i] + 1){\n                        int temp = row[j];\n                        row[j] = row[i + 1];\n                        row[i + 1] = temp;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return swap;\n}\n```\n\n你以为这样就结束了吗？\n\n\n\n### cyclic swapping\n\n上面的解法是在循环中嵌套一个循环，效果显然是不行的，通过leetcode的discuss，我学到了一种更为优秀的解法：cyclic swapping。\n\n这个解法的精华在于：`i == ptn[pos[ptn[row[i]]]]`，乍一看确实毫无头绪，但要首先了解两个额外设置的数组`ptn`和`pos`：\n\n1. `ptn[i]`指的是标签i的couple的值（i可以是位置也可以是具体的值）—— 若i为偶数，`ptn[i] = i + 1`，若i为奇数，`ptn[i] = i - 1`。\n2. `pos[i]`指的是标签i在row数组（也就是给定的随机数组）中的index —— `row[pos[i]] == i`。\n\n这样一来，`i == ptn[pos[ptn[row[i]]]]`的意思就是：\n\n1. 在位置i上的元素有值`row[i]`，我们想把它放在它couple的旁边。\n2. 首先找到它的couple的值，也就是`ptn[row[i]]`。\n3. 接着找到这个couple的位置，也就是`pos[ptn[row[i]]]`。\n4. 最后找到这个位置旁的位置，也就是`ptn[pos[ptn[row[i]]]]`。\n\n接着就可以进行调换了：\n\n```c++\nint minSwapsCouples(vector<int>& row) {\n    int res = 0, N = row.size();\n    vector<int> ptn(N, 0);\n    vector<int> pos(N, 0);\n    for (int i = 0; i < N; i++) {\n        ptn[i] = (i % 2 == 0 ? i + 1 : i - 1);\n        pos[row[i]] = i;\n    }//初始化\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = ptn[pos[ptn[row[i]]]]; i != j; j = ptn[pos[ptn[row[i]]]]) {\n            swap(row[i], row[j]);\n            swap(pos[row[i]], pos[row[j]]);\n            res++;\t//调换次数\n        }\t//这里的循环实际上只是完成一个位置的调换，如果这里的循环多于一次，后面的循环次数会减少\n    }\n        \n    return res;\n}\n```\n\n\n\n\n\n\n","tags":["算法"]},{"title":"leetcode 240 二维矩阵查值 题解","url":"/2018/09/13/leetcode240/","content":"\n\n\n## 题目\n\nWrite an efficient algorithm that searches for a value in an *m* x *n* matrix. This matrix has the following properties:\n\n- Integers in each row are sorted in ascending from left to right.\n- Integers in each column are sorted in ascending from top to bottom.\n\n**Example:**\n\nConsider the following matrix:\n\n```\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n```\n\nGiven target = `5`, return `true`.\n\nGiven target = `20`, return `false`.\n\n\n\n### 解法一\n\n拿到题目一看是查询类的，先暴力解了再说，解法就是两层循环遍历找到值。实现如下：\n\n```c++\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    if(matrix.empty() || matrix[0].empty()) return false;\n    for(int i = 0; i < matrix.size(); i++){\n        for(int j = 0; j < matrix[i].size(); j++){\n            if(matrix[i][j] == target){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n容易看出，这样做的复杂度达到了O(m*n)（m、n对应矩阵的行和列），肯定是不能够让人满意的。\n\n\n\n### 解法二\n\n接下来有哪些地方可以改进的呢？注意这个二维矩阵，暴力求解的时候对每一行是直接顺序扫描，那么这里可以改成对一行进行二分查找，这样一来复杂度可以减少到O(m*logn)，实现如下：\n\n```c++\nbool bisearch(vector<int>& line, int head, int tail, int target){\n    int mid = line[(head + tail) / 2];\n    if(head == tail){\n        return mid == target;\n    }\n    if(mid == target){\n        return true;\n    }\n    if(mid < target){\n        return bisearch(line, (head + tail) / 2 + 1, tail, target);\n    }\n    else{\n        return bisearch(line, head, (head + tail) / 2, target);\n    }\n}\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    if(matrix.empty() || matrix[0].empty()) return false;\n    for(int i = 0; i < matrix.size(); i++){\n        if(matrix[i].size() == 1 && matrix[i][0] == target){\n            return true;\n        }\n        else{\n            if(target > matrix[i][matrix[i].size() - 1]) continue;\n            if(target < matrix[i][0]) return false;\n            if(bisearch(matrix[i], 0, matrix[i].size() - 1, target)){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n\n\n### 解法三\n\n按照上一个解法提交后我发现成绩还是不尽人意（运行时间在所有成功提交中在中间的位置），那么还能怎么改进呢？思考了许久后，我发现是自己一开始就陷入思维定势了，因为这道题类型属于divide and conquer，所以就一直想着二分，其实并不一定要这么做。\n\n重点是要分析透彻这个矩阵的特点，它的每一行、列的元素都是按从小到大的顺序排列好的，所以每个元素的左边元素都比它小，下面元素都比它大，那么只需要从第一行最右元素开始比较，若比target小就向下移动一位（这一行剩下的不需要查找了），若比target大就向左移动一位，这样若矩阵中存在target那么肯定能够找到。其实从最后一行第一个元素开始也可以，原理是一样的。\n\n实现如下：\n\n```c++\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    if(matrix.empty() || matrix[0].empty()) return false;\n    int i = 0, j = matrix[0].size() - 1;\n    while(j >= 0 && i < matrix.size()){\n        if(matrix[i][j] == target){\n            return true;\n        }\n        else if(matrix[i][j] > target){\n            j--;\n        }\n        else{\n            i++;\n        }\n    }\n    return false;\n}\n```\n\n值得一提的是，这样完成的复杂度最差情况下为O(m+n)。\n\n\n\n","tags":["算法"]},{"title":"Win10环境下安装配置VirtualBox，搭建CentOS私有云","url":"/2018/09/09/vbox-cfg/","content":"\n\n\n友情链接：\n\n1. [Win10环境下搭建Ubuntu私有云](https://palette25.github.io/2018/09/08/Serive-Computing-Install-Personal-Cloud/)\n2. [MAC环境下搭建Ubuntu私有云](https://blog.chenmt.science/2018/09/09/77/)\n\n（同队队员的博客，给有需要在windows、mac环境下搭建Ubuntu虚拟机的同学）\n\n\n\n## 准备工作\n\n1. 安装VirtualBox，根据自己的需要下载相应的host版本，在这里我下载的是VirtualBox 5.2.18的Windows host版，下载地址：[官网](https://www.virtualbox.org/wiki/Downloads)\n2. 安装Git客户端（git bash），下载地址：[官网](https://git-scm.com/downloads/)\n3. 下载Linux发行版镜像，可以选择在阿里云[opsx](https://opsx.alibaba.com/mirror)进行下载，在这里我选择的是CentOS7镜像进行下载。\n\n\n\n## 配置VirtualBox\n\n在创建安装虚拟机之前，要先配置虚拟机的存储位置，避免占用不必要的空间。\n\n- VirtualBox菜单：管理 → 全局设定 → 常规 → 默认虚拟电脑位置\n\n之后要创建虚拟机内部虚拟网络，是将来用来测试虚拟机与主机间通讯时要用到的。\n\n- VirtualBox菜单：管理 → 主机网络管理器\n\n将网卡改为手动配置，自行修改Ipv4地址，注意这个地址是作为虚拟内部网络host的地址，后续虚拟机的ip地址不能与之相同。\n\n配置界面：\n\n![配置界面](vbox-cfg/1.png)\n\n配置网络完成后，在主机windows命令行输入ipconfig，可以看到我们创建的网卡的信息。\n\n![网卡信息](vbox-cfg/2.png)\n\n\n\n## 配置CentOS虚拟机\n\n首先用vbox创建一个64 bit虚拟机，命名为centos-base，以便与后面另外创建的虚拟机区分。因为对于这个虚拟机计划只使用命令行操作，所以CPU、内存、显存都采用默认配置就可以，存储设置为30G，避免以后扩展麻烦。\n\n比较重要的是网络的配置：\n\n- 设置 → 网络\n\n第一块网卡设置为NAT（不用调整），这块网卡负责访问外网（通过宿主机）。第二块网卡连接方式：Host-Only，接口为之前创建的虚拟网卡VirtualBox Host-Only Ethernet Adapter #2，这块网卡负责进行虚拟网络连接。\n\n之后导入之前下载的iso文件进行系统安装，完成后进入系统。\n\n进入系统后，第一件事要升级OS系统内核：\n\n- 首先获取wget，`yum install wget`\n\n- 系统自带的源可能比较慢，可以换成163或阿里云的源，这里选择[163源](http://mirrors.163.com/.help/centos.html)进行更换：\n\n  - 首先备份/etc/yum.repos.d/CentOS-Base.repo\n\n    `mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup`\n\n  - 下载对应版本repo文件（这里为CentOS7），并放入/etc/yum.repos.d\n\n    `wget http://mirrors.163.com/.help/CentOS7-Base-163.repo `\n\n  - 运行以下命令生成缓存\n\n    `yum clean all`\n\n    `yum makecache`\n\n- 最后 `yum update`\n\n接着检查网卡配置，命令行输入nmtui，出现配置网卡的界面：\n\n![配置网卡](vbox-cfg/3.png)\n\n进入Edit之后可以看到有enp0s8、enp0s3两个以太网连接，分别对应刚才的Host-Only和NAT。对于enp0s3不用如何调整，只需要在enp0s8的edit界面设置ipv4地址：\n\n![enp0s8](vbox-cfg/4.png)\n\n设置好了不要忘记在activate界面手动激活网卡，因为这里默认开机时不会启动网卡。当然，也可以设置它开机时自动启动。找到网卡的配置文件（在/etc/sysconfig/network-scripts中），将ifcfg-enp0s8和ifcfg-enp0s3（名称对应你的网卡名称）中的ONBOOT选项都改为true，这样就能开机自启了。\n\n接下来尝试ping外网与内网：\n\n![fail](vbox-cfg/5.png)\n\n咦，为什么内网无法ping到？网卡的设置应该是没有问题的，同时我试了一下在windows这边命令行ping 192.168.106.50，也就是虚拟机地址，是没有问题的，说明应该是有一个协议使得连接只能是单向的了，那就应该是windows防火墙的问题了，win10防火墙有三种：域网络、专用网络和公共网络。关闭win10的专用网络防火墙后，果然可以了：\n\n![ok](vbox-cfg/6.png)\n\n下面开始配置第二个CentOS虚拟机，这个虚拟机只需要对centos-base进行复制就可以了，这里把新的虚拟机命名为centos-client，注意复制选项，必须选择重新初始化所有网卡的MAC地址，不然后面无法测试虚拟机之间的通信（地址相同）。最后选择**链接复制**，此时新虚拟机的虚拟硬盘是绑定到原虚拟机的虚拟硬盘的，这样虚拟机创建的就很快。\n\n同样，在第二个虚拟机中，用nmtui配置主机名与第二块网卡的地址，并测试能否ping通，测试结果都很正常。\n\n在这个虚拟机中打算使用centos 桌面，故分配给它的CPU、内存与显存都要调高一些，并使用`yum groupinstall \"GNOME Desktop\"`来安装桌面，安装成功后，设置启动目标为桌面：`ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target`，再重启，就可以看到centos桌面了：\n\n![centos](vbox-cfg/7.png)\n\n\n\n## ssh与远程桌面访问\n\n既然是建立私有云，用ssh和远程桌面访问是必不可少的。而要使用这两个工具也需要做一些工作。\n\n首先对于ssh：\n\n- 确保CentOS7安装了openssh-server，在终端输入`yum list installed | grep openssh-server`\n\n- 如果显示没有安装，就输入`yum install openssh-server`来安装\n\n- 有了openssh-server后，找到/etc/ssh/目录下的sshd_config文件并用编辑器打开，将Port、ListenAddress前的＃号去除，并把PermitRootLogin和PasswordAuthentication设为yes\n\n  ![8](vbox-cfg/8.png)\n\n  ![9](vbox-cfg/9.png)\n\n  ![10](vbox-cfg/10.png)\n\n测试ssh连接成功：\n\n![ssh2](vbox-cfg/11.png)\n\n接下来是远程桌面访问：\n\n- 首先要安装VirtualBox远程显示系统的扩展包[Oracle VM VirtualBox Extension pack](https://www.virtualbox.org/wiki/Downloads)，它提供一系列的功能支持：USB 2.0，intel网卡的PXE启动与VirtualBox远程显示系统。安装完成后，重启宿主机。\n\n- 设置虚拟机访问端口：点击虚拟机设置 → 显示 → 远程桌面 → 启用服务器并设置连接端口，注意连接时用的是宿主机的IP地址加上子机的端口（也就是192.168.106.1:（设置的端口）），每台虚拟机必须拥有唯一的RDP访问端口。\n\n- 最后，用Windows的Remote Desktop Connection（远程桌面连接）终端进行远程桌面访问（注意先启动虚拟机）\n\n  ![rdc](vbox-cfg/12..png)\n\n  ![ssh2](vbox-cfg/13.png)\n\n\n\n这样以来，私有云就搭建好了，可以开始愉快的玩耍了~\n\n\n\n\n\n\n","tags":["服务计算"]},{"title":"CCF 201803-2 碰撞的小球 题解","url":"/2018/09/06/CCF201803-2/","content":"\n最近准备参加CCF认证，刷一下这里的题目。\n\n\n\n## 题目\n\n**问题描述**\n\n数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。\n\n当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。\n\n当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。\n\n现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。\n\n\n\n**提示**\n\n因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。\n\n同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。\n\n\n\n**输入格式**\n\n输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。\n\n第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。\n\n\n\n**输出格式**\n\n输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。\n\n\n\n**Example :**\n\n```\nInput: 3 10 5\n\t   4 6 8\nOutput: 7 9 9\n```\n\n\n\n## 题解\n\n一开始可能有点懵，不过想到每个小球都有自己的运动方向、位置，就可以联想到建立对象来解题。\n\n```c++\nint length;\t//每个球都再判断是否碰墙的时候都需要这个值\nclass Ball{\n    public:\n        Ball(){\n            direction = 1;\n            this->pos = 0;\n        }\n        int getpos(){\n            return pos;\n        }\n        void initpos(int pos){\n            this->pos = pos;\n        }\n        void move(){\n            pos = (direction) ? pos + 1 : pos - 1;\n        }\n        bool againstwall(){\n            return (pos == 0 || pos == length) ? true : false;\n        }\n        void turn(){\n            direction = (direction == 1) ? 0 : 1;\n        }\n    private:\n        int pos;\n        int direction;\n};\n```\n\n\n\n类建好后，解题就比较简单了。\n\n```c++\nint main(){\n    int numofball, time;\n    cin >> numofball >> length >> time;\n    Ball *balls = new Ball[numofball];\n    for(int i = 0; i < numofball; i++){\n        int pos;\n        cin >> pos;\n        balls[i].initpos(pos);\n    }\n    while(time--){\n        for(int i = 0; i < numofball; i++){\n            balls[i].move();\n            if(balls[i].againstwall()){\n                balls[i].turn();\n            }\n        }\n        for(int i = 0; i < numofball - 1; i++){\n            for(int j = i + 1; j < numofball; j++){\n                if(balls[i].getpos() == balls[j].getpos()){\n                    balls[i].turn();\n                    balls[j].turn();\n                    break;\n                }\n            }\n        }\n    }\n    for(int i = 0; i < numofball; i++){\n        cout << balls[i].getpos() << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n```\n\n\n\n这里球跟球之间的碰撞处理的比较简单粗暴，不过暂时也没有想到更好的方法（其实是懒），就先这样吧。","tags":["算法"]},{"title":"leetcode 05 最长子回文串 题解","url":"/2018/09/05/leetcode05/","content":"\n## 题目\n\nGiven a string **s**, find the longest palindromic substring in **s**. You may assume that the maximum length of **s** is 1000.\n\n**Example 1:**\n\n```\nInput: \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer.\n```\n\n  \n\n**Example 2:**\n\n```\nInput: \"cbbd\"\nOutput: \"bb\"\n```\n\n\n\n### 解法一\n\n首先想到的当然是暴力解法了，对字符串的每一子字符串都进行是否为回文字符串的判定。所谓回文字符串就是正反都一样的字符串。\n\n解法如下：\n\n```c++\nbool isPalindrome(string s){\n    for(int i = 0; i < s.length() / 2; i++){\n        if(s[i] != s[s.length() - 1 - i]){\n            return false;\n        }\n    }\n    return true;\n}\nstring longestPalindrome(string s) {\n    int maxlength = 1;\n    string longeststr = s.substr(0, 1);\n    for(int i = 0; i < s.length(); i++){\n        if(maxlength >= s.length() - i) return longeststr;\n        for(int j = maxlength + 1; j <= s.length() - i; j++){\n            if(isPalindrome(s.substr(i, j))){\n                if(j > maxlength){\n                    longeststr = s.substr(i, j);\n                    maxlength = j;\n                }\n            }\n        }\n    }\n    return longeststr;\n}\n```\n\n这里也对暴力解法进行了一些优化，比如在外层循环时，如果已经得到的最长回文字符串的长度大于此时要处理的子字符串的长度就直接返回；内存循环直接从此时得到的最长回文字符串的长度+1开始。然而，可以想见的是，效果依然是很差的。\n\n\n\n### 解法二\n\n之后思考许久也没有找到更好的算法，遂查看leetcode的提示，提示是说在寻找新的更长的回文字符串时，要用到已计算的回文字符串。这样一来可以减少判断回文字符串的时间。\n\n解法如下：\n\n```c++\nstring longestPalindrome(string s) {\n    int minstart = 0, maxlength = 1;\n    for(int i = 0; i < s.size(); i++){\n        int sub = i, add = i;\n        while(add < s.size() - 1 && s[add + 1] == s[add]){\n            add++;\n        }\n        while(sub > 0 && add < s.size() - 1 && s[add + 1] == s[sub - 1]){\n            add++;\n            sub--;\n        }\n        int newlength = add - sub + 1;\n        if(newlength > maxlength){\n            minstart = sub;\n            maxlength = newlength;\n        }\n    }\n    return s.substr(minstart, maxlength);\n}\n```\n\n这个解法是每次以循环位置i为中心，向两端扩展找到最长的回文字符串，在判断是否为回文字符串时，实际上只用判断s[add + 1] == s[sub - 1]，也就是这一步时间复杂度仅为O(1)，这样就大幅缩短了算法运行的时间。\n\n","tags":["算法"]}]