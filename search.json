[{"title":"leetcode 05 最长子回文串 题解","url":"/2018/09/05/leetcode05/","content":"\n## 题目\n\nGiven a string **s**, find the longest palindromic substring in **s**. You may assume that the maximum length of **s** is 1000.\n\n**Example 1:**\n\n```\nInput: \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer.\n```\n\n  \n\n**Example 2:**\n\n```\nInput: \"cbbd\"\nOutput: \"bb\"\n```\n\n\n\n### 解法一\n\n首先想到的当然是暴力解法了，对字符串的每一子字符串都进行是否为回文字符串的判定。所谓回文字符串就是正反都一样的字符串。\n\n解法如下：\n\n```c++\nbool isPalindrome(string s){\n    for(int i = 0; i < s.length() / 2; i++){\n        if(s[i] != s[s.length() - 1 - i]){\n            return false;\n        }\n    }\n    return true;\n}\nstring longestPalindrome(string s) {\n    int maxlength = 1;\n    string longeststr = s.substr(0, 1);\n    for(int i = 0; i < s.length(); i++){\n        if(maxlength >= s.length() - i) return longeststr;\n        for(int j = maxlength + 1; j <= s.length() - i; j++){\n            if(isPalindrome(s.substr(i, j))){\n                if(j > maxlength){\n                    longeststr = s.substr(i, j);\n                    maxlength = j;\n                }\n            }\n        }\n    }\n    return longeststr;\n}\n```\n\n这里也对暴力解法进行了一些优化，比如在外层循环时，如果已经得到的最长回文字符串的长度大于此时要处理的子字符串的长度就直接返回；内存循环直接从此时得到的最长回文字符串的长度+1开始。然而，可以想见的是，效果依然是很差的。\n\n\n\n### 解法二\n\n之后思考许久也没有找到更好的算法，遂查看leetcode的提示，提示是说在寻找新的更长的回文字符串时，要用到已计算的回文字符串。这样一来可以减少判断回文字符串的时间。\n\n解法如下：\n\n```c++\nstring longestPalindrome(string s) {\n    int minstart = 0, maxlength = 1;\n    for(int i = 0; i < s.size(); i++){\n        int sub = i, add = i;\n        while(add < s.size() - 1 && s[add + 1] == s[add]){\n            add++;\n        }\n        while(sub > 0 && add < s.size() - 1 && s[add + 1] == s[sub - 1]){\n            add++;\n            sub--;\n        }\n        int newlength = add - sub + 1;\n        if(newlength > maxlength){\n            minstart = sub;\n            maxlength = newlength;\n        }\n    }\n    return s.substr(minstart, maxlength);\n}\n```\n\n这个解法是每次以循环位置i为中心，向两端扩展找到最长的回文字符串，在判断是否为回文字符串时，实际上只用判断s[add + 1] == s[sub - 1]，也就是这一步时间复杂度仅为O(1)，这样就大幅缩短了算法运行的时间。\n\n","tags":["算法"]}]