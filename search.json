[{"title":"CCF 201803-2 碰撞的小球 题解","url":"/2018/09/06/CCF201803-2/","content":"\n最近准备参加CCF认证，刷一下这里的题目。\n\n\n\n## 题目\n\n**问题描述**\n\n数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。\n\n当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。\n\n当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。\n\n现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。\n\n\n\n**提示**\n\n因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。\n\n同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。\n\n\n\n**输入格式**\n\n输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。\n\n第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。\n\n\n\n**输出格式**\n\n输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。\n\n\n\n**Example :**\n\n```\nInput: 3 10 5\n\t   4 6 8\nOutput: 7 9 9\n```\n\n\n\n## 题解\n\n一开始可能有点懵，不过想到每个小球都有自己的运动方向、位置，就可以联想到建立对象来解题。\n\n```c++\nint length;\t//每个球都再判断是否碰墙的时候都需要这个值\nclass Ball{\n    public:\n        Ball(){\n            direction = 1;\n            this->pos = 0;\n        }\n        int getpos(){\n            return pos;\n        }\n        void initpos(int pos){\n            this->pos = pos;\n        }\n        void move(){\n            pos = (direction) ? pos + 1 : pos - 1;\n        }\n        bool againstwall(){\n            return (pos == 0 || pos == length) ? true : false;\n        }\n        void turn(){\n            direction = (direction == 1) ? 0 : 1;\n        }\n    private:\n        int pos;\n        int direction;\n};\n```\n\n\n\n类建好后，解题就比较简单了。\n\n```c++\nint main(){\n    int numofball, time;\n    cin >> numofball >> length >> time;\n    Ball *balls = new Ball[numofball];\n    for(int i = 0; i < numofball; i++){\n        int pos;\n        cin >> pos;\n        balls[i].initpos(pos);\n    }\n    while(time--){\n        for(int i = 0; i < numofball; i++){\n            balls[i].move();\n            if(balls[i].againstwall()){\n                balls[i].turn();\n            }\n        }\n        for(int i = 0; i < numofball - 1; i++){\n            for(int j = i + 1; j < numofball; j++){\n                if(balls[i].getpos() == balls[j].getpos()){\n                    balls[i].turn();\n                    balls[j].turn();\n                    break;\n                }\n            }\n        }\n    }\n    for(int i = 0; i < numofball; i++){\n        cout << balls[i].getpos() << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n```\n\n\n\n这里球跟球之间的碰撞处理的比较简单粗暴，不过暂时也没有想到更好的方法（其实是懒），就先这样吧。","tags":["算法"]},{"title":"leetcode 05 最长子回文串 题解","url":"/2018/09/05/leetcode05/","content":"\n## 题目\n\nGiven a string **s**, find the longest palindromic substring in **s**. You may assume that the maximum length of **s** is 1000.\n\n**Example 1:**\n\n```\nInput: \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer.\n```\n\n  \n\n**Example 2:**\n\n```\nInput: \"cbbd\"\nOutput: \"bb\"\n```\n\n\n\n### 解法一\n\n首先想到的当然是暴力解法了，对字符串的每一子字符串都进行是否为回文字符串的判定。所谓回文字符串就是正反都一样的字符串。\n\n解法如下：\n\n```c++\nbool isPalindrome(string s){\n    for(int i = 0; i < s.length() / 2; i++){\n        if(s[i] != s[s.length() - 1 - i]){\n            return false;\n        }\n    }\n    return true;\n}\nstring longestPalindrome(string s) {\n    int maxlength = 1;\n    string longeststr = s.substr(0, 1);\n    for(int i = 0; i < s.length(); i++){\n        if(maxlength >= s.length() - i) return longeststr;\n        for(int j = maxlength + 1; j <= s.length() - i; j++){\n            if(isPalindrome(s.substr(i, j))){\n                if(j > maxlength){\n                    longeststr = s.substr(i, j);\n                    maxlength = j;\n                }\n            }\n        }\n    }\n    return longeststr;\n}\n```\n\n这里也对暴力解法进行了一些优化，比如在外层循环时，如果已经得到的最长回文字符串的长度大于此时要处理的子字符串的长度就直接返回；内存循环直接从此时得到的最长回文字符串的长度+1开始。然而，可以想见的是，效果依然是很差的。\n\n\n\n### 解法二\n\n之后思考许久也没有找到更好的算法，遂查看leetcode的提示，提示是说在寻找新的更长的回文字符串时，要用到已计算的回文字符串。这样一来可以减少判断回文字符串的时间。\n\n解法如下：\n\n```c++\nstring longestPalindrome(string s) {\n    int minstart = 0, maxlength = 1;\n    for(int i = 0; i < s.size(); i++){\n        int sub = i, add = i;\n        while(add < s.size() - 1 && s[add + 1] == s[add]){\n            add++;\n        }\n        while(sub > 0 && add < s.size() - 1 && s[add + 1] == s[sub - 1]){\n            add++;\n            sub--;\n        }\n        int newlength = add - sub + 1;\n        if(newlength > maxlength){\n            minstart = sub;\n            maxlength = newlength;\n        }\n    }\n    return s.substr(minstart, maxlength);\n}\n```\n\n这个解法是每次以循环位置i为中心，向两端扩展找到最长的回文字符串，在判断是否为回文字符串时，实际上只用判断s[add + 1] == s[sub - 1]，也就是这一步时间复杂度仅为O(1)，这样就大幅缩短了算法运行的时间。\n\n","tags":["算法"]}]