[{"title":"Go语言实现Selpg","url":"/2018/10/11/selpg/","content":"\n\n\n实现：[github](https://github.com/Krazymud/firstgo/tree/master/selpg)\n\n\n## 前言\n\n本文介绍了使用GO语言实现Selpg这样一个程序的过程，总体参考了[开发Linux命令行实用程序](https://www.ibm.com/developerworks/cn/linux/shell/clutil/index.html)这篇文章，它讲的是使用C语言实现Selpg。Selpg即Select Pages，允许用户指定从输入文本（可来自文件或命令行或是另一个进程的输出）抽取的页的范围，并控制输出的位置，可以是标准输出，也可以输入至文件或子进程。\n\n\n\n## Usage\n\n```shell\nUsage: selpg [-s startPage] [-e endPage] [-l linesPerPage | -f] [-d printDest] filename\n\nOptions:\n  -d, --dest string\t\t(Optional) Enter printing destination\n  -e, --endPage int\t\t(Mandatory) Input Your endPage\n  -f, --pageBreak\t\t(Optional) Choosing pageBreaks mode\n  -l, --pageLen int     (Optional) Choosing pageLen mode, enter pageLen\n  -s, --startPage int\t(Mandatory) Input Your startPage\n```\n\n\n\n## 代码结构\n\n总共有三个函数：\n\n- main函数：解析命令参数的入口函数\n- processArgs函数：处理参数，进行错误处理\n- processInput函数：经过processArgs函数后，这里根据命令进行（文件）操作\n\n除此之外，还有保存参数的struct：selpgArgs，以及五个解析参数用的flag。\n\nselpgArgs存储内容：\n\n```go\ntype selpgArgs struct {\n\tstartPage, endPage, pageLen, pageType int\n\tinFilename                            string\n\tprintDest                             string\n}\n```\n\n\n\n## 关键实现\n\n1. pflag\n\n   在前面的参考文章中，可以看到如果使用C语言来解析参数，代码实现还是比较繁杂的，需要手动进行参数的获取、判断乃至解析。而在Go语言中，有很多便利的包供我们使用，在这里使用的是pflag这个包来进行参数的解析。\n\n   pflag包的使用是非常简单的，首先`go get`了这个包([spf13/pflag](https://github.com/spf13/pflag))之后，引入它就可以使用了。基本的参数绑定操作：\n\n   ```go\n   var ip *int = flag.Int(\"flagname\", 1234, \"help message for flagname\")\t//绑定\"--flagname\"的值到*ip上，格式为int\n   //或\n   var flagvar int\t\t//声明\n   func init() {\n       flag.IntVar(&flagvar, \"flagname\", 1234, \"help message for flagname\")\t//绑定\n   }\n   ```\n\n   在Selpg中，我们需要两种格式的参数，拿输入文本的起始页做例子，我们就需要同时接受`--startPage`与`-s`这两种输入，pflag也允许我们这样做：\n\n   ```go\n   var inputS = flag.IntP(\"startPage\", \"s\", -1, \"...\")\n   //startPage配合\"--\"使用，s配合\"-\"使用\n   ```\n\n   最后，`flag.Parse()`自动进行参数的捕获、解析。如果是没有带`-`或`--`的参数，则可通过`flag.Args()`获取，这类参数的数量为`flag.Narg()`。\n\n2. bufio\n\n   在Selpg的实现中我使用了bufio包来进行输入输出的定向，bufio即buffered I/O，它封装了io.Reader与io.Writer，使用起来还是较为方便的。\n\n   读取输入部分：\n\n   ```go\n   //从命令行输入\n   inputReader = bufio.NewReader(os.Stdin) \n   //或打开一个文件后输入\n   file, err = os.Open(selpg.inFilename)\n   \tif err != nil {\n   \t\tfmt.Fprintln(os.Stderr, err)\n   \t\tos.Exit(1)\n   \t}\n   inputReader = bufio.NewReader(file)\t\n   //读取输入，直到某一字符（包含此字符）\n   line, err = inputReader.ReadBytes('\\n')\t//换页为行模式\n   line, err = inputReader.ReadBytes('\\f')\t//换页为换页符模式\n   ```\n\n   定向输出部分：\n\n   ```go\n   outputWriter = bufio.NewWriter(os.Stdout)\n   outputWriter.Write(line)\n   outputWriter.Flush()\t//这一步必须\n   ```\n\n3. os/exec\n\n   \"-dXXX\"的实现可能是比较难的一部分，这里通过os/exec包来实现，exec允许运行外部命令，它封装了os.StartProcess，故我们可以更容易地重定向输入输出，可通过管道向命令输入内容。\n\n   当`-d`参数获得了一个打印机地址，就进行如下操作：\n\n   ```go\n   //初始化外部命令\n   cmd = exec.Command(\"lp\", \"-d\", selpg.printDest)\t\n   //建立一个管道以输入打印内容\n   stdin, err = cmd.StdinPipe()\n   //写入管道\n   _, err := io.WriteString(stdin, string(line))\n   //关闭管道、获得输出\n   stdin.Close()\n   stderr, _ := cmd.CombinedOutput()\n   ```\n\n   注意`cmd.CombinedOutput()`的作用是运行命令并获得组合在一起的stdout/stderr输出。\n\n\n\n## 简单测试\n\n1. `selpg -s1 -e1`\n\n   即，从命令行输入，并输出到命令行，打印前72行（default）\n\n   ![1](selpg/1.png)\n\n2. `selpg -s1 -e1 -l3 input`\n\n   即，从文件输入，并输出到命令行，打印前三行\n\n   ![2](selpg/2.png)\n\n3. `selpg -s1 -e input >output 2>error`\n\n   即，正确输出到文件output，错误输出至文件error（故意写成错误命令）\n\n   ![3](selpg/3.png)\n\n4. 测试换页符，首先建立包含换页符的文件：\n\n   ![4](selpg/4.png)\n\n   接着，测试`selpg -s1 -e3 -f input`\n\n   ![5](selpg/5.png)\n\n5. 测试输出至打印机lp1\n\n   ![6](selpg/6.png)\n\n   命令正确执行了，只是没有打印机\n\n6. `selpg -s1 -e20 -l20 test.txt | grep -n \"Geralt\"`\n\n   测试读取并输出长篇小说的前20页（设置每页长20行）\n\n   ![Geralt](selpg/7.png)\n\n\n\n这样就实现了selpg程序。","tags":["服务计算"]},{"title":"leetcode 841 KeysAndRooms 题解","url":"/2018/10/11/leetcode841/","content":"\n\n\n## 题目\n\nThere are `N` rooms and you start in room `0`.  Each room has a distinct number in `0, 1, 2, ..., N-1`, and each room may have some keys to access the next room. \n\nFormally, each room `i` has a list of keys `rooms[i]`, and each key `rooms[i][j]` is an integer in `[0, 1, ..., N-1]`where `N = rooms.length`.  A key `rooms[i][j] = v` opens the room with number `v`.\n\nInitially, all the rooms start locked (except for room `0`). \n\nYou can walk back and forth between rooms freely.\n\nReturn `true` if and only if you can enter every room.\n\n\n\n**Example 1:**\n\n```\nInput: [[1],[2],[3],[]]\nOutput: true\nExplanation:  \nWe start in room 0, and pick up key 1.\nWe then go to room 1, and pick up key 2.\nWe then go to room 2, and pick up key 3.\nWe then go to room 3.  Since we were able to go to every room, we return true.\n```\n\n**Example 2:**\n\n```\nInput: [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We can't enter the room with number 2.\n```\n\n**Note:**\n\n1. `1 <= rooms.length <= 1000`\n2. `0 <= rooms[i].length <= 1000`\n3. The number of keys in all rooms combined is at most `3000`.\n\n\n\n### 解法\n\n总的来说，就是数组的每个位是一个房间，房间中存有通往其他房间的钥匙，从0号房间开始，问是否能走完全部房间。于是马上想到了BFS算法，只要最后所有位置都visit过，就能够走完所有房间。\n\n代码如下：\n\n```c++\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\n    vector<int> visited(rooms.size(), 0);\t//已到过的房间\n    queue<int> tovisit;\t\t//将要去的房间\n    tovisit.push(0);\n    visited[0] = 1;\n    while(!tovisit.empty()){\n        int curr = tovisit.front();\n        tovisit.pop();\n        for(auto r : rooms[curr]){\n            if(!visited[r]){\n                tovisit.push(r);\n                visited[r] = 1;\n            }\n        }\n    }\n    for(int i = 0; i < rooms.size(); i++){\n        if(!visited[i]){\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n","tags":["算法"]},{"title":"leetcode 877 Stone Game 题解","url":"/2018/10/06/leetcode877/","content":"\n\n\n国庆长假，水一题\n\n\n## 题目\n\nAlex and Lee play a game with piles of stones.  There are an even number of piles **arranged in a row**, and each pile has a positive integer number of stones `piles[i]`.\n\nThe objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.\n\nAlex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins.\n\nAssuming Alex and Lee play optimally, return `True` if and only if Alex wins the game.\n\n \n\n**Example 1:**\n\n```\nInput: [5,3,4,5]\nOutput: true\nExplanation: \nAlex starts first, and can only take the first 5 or the last 5.\nSay he takes the first 5, so that the row becomes [3, 4, 5].\nIf Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.\nIf Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alex, so we return true.\n```\n\n \n\n**Note:**\n\n1. `2 <= piles.length <= 500`\n2. `piles.length` is even.\n3. `1 <= piles[i] <= 500`\n4. `sum(piles)` is odd.\n\n\n\n### 解法一\n\n第一种解法是使用动态规划，注意到每次Alex和Lee的操作都是从piles的头或尾取走一个最大的数，那么就可以把问题分解到多个子问题上分别来解决。\n\n先构建一个数组存储piles的备份，以及一个二维数组存储各个子问题的解：\n\n```c++\nvector<vector<int>> dparr;\nvector<int> p;\nbool stoneGame(vector<int>& piles) {\n    p = piles;\n    int size = piles.size();\n    vector<vector<int>> tmp(size, vector<int>(size, 0));\n    dparr = tmp;\n    return dp(0, size - 1) > 0;\n}\n```\n\n下面是dp的具体实现，这里将Lee的操作视为从Alex的得分中扣除，最后只要Alex的得分大于零则Alex胜利：\n\n```c++\nint dp(int low, int high){\n    if(low == high){\n        return 0;\n    }\n    if(dparr[low][high] != 0){\t//避免重复计算\n        return dparr[low][high];\n    }\n    int res = 0;\n    if((high - low + 1) % 2 == 0){  //Alex\n        res = max(dp(low + 1, high) + p[low], dp(low, high - 1) + p[high]);\n    } \n    else{\t//Lee\n        res = min(dp(low + 1, high) - p[low], dp(low, high - 1) - p[high]);\n    }\n    dparr[low][high] = res;\n    return res;\n}\n```\n\n\n\n### 解法二\n\n让我们回到问题：数组中一共有偶数个元素，Alex先选，Lee后选。那么假设数组有2n个元素，如果Alex第一次选择了元素1，则Lee可以选择2或2n，在之后Alex可以选择3、2n或者2、2n-1，以此类推。也就是说，可以保证Alex一定能够选到所有奇数位置的元素或是所有偶数位置的元素，那么只要一开始知道奇数位置元素之和与偶数位置元素之和哪个更大，就能保证Alex胜利，所以实际上这道题我们只需要：\n\n```c++\nreturn true;\n```\n\n就能够通过。\n\n\n\n","tags":["算法"]},{"title":"leetcode 847 访问所有节点的最短路径 题解","url":"/2018/09/27/leetcode847/","content":"\n\n\n## 题目\n\nAn undirected, connected graph of N nodes (labeled `0, 1, 2, ..., N-1`) is given as `graph`.\n\n`graph.length = N`, and `j != i` is in the list `graph[i]` exactly once, if and only if nodes `i` and `j` are connected.\n\nReturn the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.\n\n \n\n**Example 1:**\n\n```\nInput: [[1,2,3],[0],[0],[0]]\nOutput: 4\nExplanation: One possible path is [1,0,2,0,3]\n```\n\n**Example 2:**\n\n```\nInput: [[1],[0,2,4],[1,3,4],[2],[1,2]]\nOutput: 4\nExplanation: One possible path is [0,1,4,2,3]\n```\n\n \n\n**Note:**\n\n1. `1 <= graph.length <= 12`\n2. `0 <= graph[i].length < graph.length`\n\n\n\n### 解法一\n\n这周刚好学到了BFS、Dijkstra、Bellman–Ford等处理图论问题的算法，这里就能够用上了。这一题是要在无向图中找到经过了每一个节点的最短路径，可以很快想到可以用BFS算法，但是再一想，BFS算法可以用来找两点间最短路径，而这里并没有给出起点和终点，只是单纯的找到一条经过每个节点的最短路径，怎么办呢？\n\n以往使用BFS算法时，是将节点不断加入、弹出队列，在这里我们可以换种思路，比如把从各个节点开始的路径加入、更新、弹出队列，并记录此时路径对应的长度，直到队列为空时，此时经过了所有节点的路径的长度应该被更新了许多次，达到了最小。\n\n首先需要构建一个struct类型，代表此时的路径状态：\n\n```c++\nstruct state{\n    int visited, tovisit;\t//已经过的节点，要访问的节点\n    state(int v, int t){\n        visited = v;\n        tovisit = t;\n    }\n};\n```\n\n用bits来记录经过的节点：从第n号节点开始即为`1 << n = 1...00`（n个0），访问完所有节点的路径状态应该是`011..1`，哪一位为1即代表经过了哪一位，访问节点的邻居后的节点状态这样表示：`visited | (1 << neighbour)`。\n\n接下来是实现：\n\n```c++\nint shortestPathLength(vector<vector<int>>& graph) {\n    int n = graph.size();\n    queue<state> mqueue;\n    vector<vector<int>> dist(1 << n, vector<int>(n, n * n));\n    for(int i = 0; i < n; i++){\n        mqueue.push(state(1 << i, i));\t//queue中一开始设置各个节点开始的初始路径\n        dist[1 << i][i] = 0;\n    }\n    while(!mqueue.empty()){\n        state node = mqueue.front();\n        mqueue.pop();\n        int dis = dist[node.visited][node.tovisit];\n        if(node.visited == (1 << n) - 1) return dis;\n        for(int neighbour : graph[node.tovisit]){\t//通过graph访问节点邻居\n            int visited2 = node.visited | (1 << neighbour);\n            if(dis + 1 < dist[visited2][neighbour]){\t//路径更短则更新\n                dist[visited2][neighbour] = dis + 1;\n                mqueue.push(state(visited2, neighbour));\t//更新后的路径状态再加入queue\n            }\n        }\n    }\n}\n```\n\n比较难想到的地方就是对路径状态进行BFS。\n\n\n\n### 解法二\n\n通过官方solution发现了第二种使用了Dynamic Programming的解法，大体上其实和BFS差不多，都是对路径状态进行操作。\n\n解法如下：\n\n```c++\nint shortestPathLength(vector<vector<int>>& graph) {\n    int n = graph.size();\n    vector<vector<int>> dist(1 << n, vector<int>(n, n * n));\n    for(int i = 0; i < n; i++){\n        dist[1 << i][i] = 0;\n    }\n    for(int visited = 0; visited < 1 << n; ++visited){\n        bool repeat = true;\n        while(repeat){\n            repeat = false;\n            for(int tovisit = 0; tovisit < n; ++tovisit){\n                int dis = dist[visited][tovisit];\n                for(int neighbour : graph[tovisit]){\n                    int visited2 = visited | (1 << neighbour);\n                    if(dis + 1 < dist[visited2][neighbour]){\n                        dist[visited2][neighbour] = dis + 1;\n                        if(visited2 == visited) repeat = true;\n                    }\n                }\n            }\n        }\n    }\n    int ans = n * n;\n    for(int i : dist[(1 << n) - 1]){\n        ans = min(i, ans);\n    }\n    return ans;\n}\n```\n\n可以看到，这种解法是通过多重循环，对dist中每一种路径状态进行更新，最后取都是经过每个节点的路径中最短的一条。\n\n\n\n\n\n","tags":["算法"]},{"title":"CentOS下GO开发环境安装与配置","url":"/2018/09/26/go-env/","content":"\n\n\n## 前情提要\n\n在[Win10环境下安装配置VirtualBox，搭建CentOS私有云](https://krazymud.github.io/2018/09/09/vbox-cfg/)一节中我们已经成功的配置好了虚拟机上的CentOS私有云，今天就来研究一下GO的开发环境的安装与配置。\n\n\n\n## 安装、配置步骤\n\n### 1. 安装golang\n\n可以选择在[官方下载页](https://golang.org/dl/)处找到最新的版本来下载安装，这里省事起见选择了直接用系统包管理工具安装：\n\n```shell\n# sudo yum install golang\n```\n\n安装完后调用`go version`命令查看版本号，这里安装的是go 1.9.4\n\n查看go都安装在了哪里：\n\n```shell\n# rpm -ql golang\n```\n\n\n\n### 2. 配置golang环境\n\ngo工具为公共代码仓库中维护的开源代码而设计，用go所编写的代码必须放在**工作空间**内，它包含三个子目录：\n\n- src目录包含Go的源文件，它们被组织成包（一个目录对应一个包），是运行`go install`、`go run`等命令时的当前路径\n- pkg目录包含包对象（golang编译的.a中间文件）\n- bin目录包含可执行文件\n\n创建工作空间目录并设置GOPATH：\n\n```shell\n# mkdir $HOME/gowork\n# export GOPATH=$HOME/work\n```\n\n并将工作空间中的bin目录添加到PATH中，以便以后直接运行安装的go程序：\n\n```shell\n# export PATH=$PATH:$GOPATH/bin\n```\n\n最后使这些配置生效：\n\n```shell\n# source $HOME/.profile\n```\n\n检查配置可以通过：\n\n```shell\n# go env\n```\n\n\n\n### 3. 安装vscode编辑器与其他\n\n**vscode安装**\n\n在开始愉快的用go玩耍前还需要安装一款适合你的编辑器，这里选择的是vscode，巨硬大法好嘛。\n\n在[官方教程](https://code.visualstudio.com/docs/setup)中有展示各个平台的安装流程，在CentOS平台上的安装命令：\n\n```shell\n# sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc\n# sudo sh -c 'echo -e \"[code]\\nname=Visual Studio Code\\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\" > /etc/yum.repos.d/vscode.repo'\n# yum check-update\t//检查更新\n# sudo yum install code\n```\n\n**git安装**\n\n打开vscode后如果你没有安装git那么它会提醒你安装，如果你之前使用`yum`命令安装过的话它会提醒你版本太老（CentOS下），所以这里选择手动安装最新版本的git。\n\n首先安装一些后续需要的依赖包：\n\n```shell\n# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel\n# yum install  gcc perl-ExtUtils-MakeMaker\n```\n\n接着如果之前有装过旧版本的话需要卸载：\n\n```shell\n# yum remove git\n```\n\n然后wget下载官方最新版本：\n\n```shell\n# wget https://www.kernel.org/pub/software/scm/git/git-2.9.2.tar.gz\n# tar -zxvf git-2.9.2.tar.gz\n```\n\n最后，编译安装，配置环境：\n\n```shell\n# cd git-2.9.2\n# make prefix=/usr/local/git all\n# make prefix=/usr/local/git install\n# echo \"export PATH=$PATH:/usr/local/git/bin\" >> /etc/bashrc\n# source /etc/bashrc\n```\n\n如果安装出错，应该是还有什么依赖没有安装好，根据提示手动安装就可以。\n\n检查git版本：\n\n```shell\n# git version\ngit version 2.9.2\n```\n\n**注意：如果安装完查看版本不是我们安装的最新版，请重新执行下面的操作**\n\n```shell\n# yum remove -y git\n# source /etc/bashrc\n# git --version\n```\n\n**工具包安装**\n\n现在总能够开始写go了吧？在vscode创建一个hello.go刚写了条package就发现又报错了，原来是很多golang的tools没有安装，根据vscode的提示一键安装，然而[golang.org](https://golang.org)并不能连上，于是，这一步也要我们手动安装。\n\n首先在go工作空间的src目录下建立一个golang.org文件夹，在其中再建立一个x文件夹，cd切换到x文件夹下，下载插件包：\n\n```shell\n# git clone https://github.com/golang/tools.git tools\n# git clone https://github.com/golang/lint.git lint\n```\n\n执行完毕后，在x文件夹下会多两个文件夹tools和lint。\n\n最后执行安装命令，安装在vscode中没有安装的工具包，例如：\n\n```shell\n# go install golang.org/x/tools/cmd/guru\n# go install golang.org/x/tools/cmd/gorename\n# go install golang.org/x/tools/cmd/gorename\n# go install golang.org\\x\\lint\\golint\n...\n```\n\n配置成功！接下来可以使用vs code创建hello.go测试一下：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Printf(\"hello, world\\n\")\n}\n```\n\n在终端运行！\n\n```shell\n# go run hello.go\nhello, world\n```\n\n\n\n### 4. 绑定远程仓库\n\n现在你的go工作空间的架构应该类似这样：\n\n```shell\nbin/\n\t...                         # 可执行命令\npkg/\n\tlinux_amd64/\n\t\t...\t\t\t\t\t\t# 包对象\nsrc/\t\t\t\t\t\t\t#源码\n\tgithub.com/\n\t\t...\n\tgolang.org/\n\t\t...\n```\n\n此时需要在github.com文件夹下创建一个和你自己github账号名称一样的文件夹，这个文件夹作为以后与远程库同步的存放go代码的文件夹，在这个文件夹下可以创建各种包。\n\n在你的github账号上手动创建一个远程库，之后根据提示，在本地文件夹中：\n\n```shell\n# echo \"# xxx\" >> README.md\n# git init\n# git add README.md\n# git commit -m \"first commit\"\n# git remote add origin https://github.com/username/xxx.git\n# git push -u origin master\n```\n\n之后每次git add、commit后要push时，都要输入自己的账号、密码来操作。当然也可以选择用git ssh，这里就不介绍了。\n\n\n\n\n\n\n\n","tags":["服务计算"]},{"title":"初步认识区块链","url":"/2018/09/22/blockchain/","content":"\n\n\n自中本聪在2008年于《比特币白皮书》中提出“区块链”概念，并在2009年开发第一个区块即“创世区块”起，十年的时间过去了。在这十年的时间中，区块链技术已有长足的发展，开始初步的进入应用领域、大众视野。而同时，它也面临着许多挑战，这些挑战亟待更多的人来研究、解决。\n\t\n区块链是借由密码学串接并保护内容的串联交易记录（区块），每个区块包含着前一个区块的加密散列、相应时间戳以及交易数据。它的优点都基于其去中心化的特点，得以在节点无需互相信任的分布式系统中实现基于去中心化信用的点对点交易、协调与协作。举例来说，在现有的中心化信用系统中，交易行为都要通过某个中心化的机构来认证，而在区块链中，认证不是由某一个中心机构进行的，而是记录在每个节点上，是透明化、可追溯的。这样就为解决中心化机构普遍存在的高成本、低效率以及数据存储不安全等问题提供了解决方案。\n\n在优点之外，区块链也面临着许多问题与挑战，这里介绍其中的一部分：\n\n1. 人才匮乏。目前来说，尽管相应的技术与产业发展的很快，但相关学术研究严重滞后。技术创新缺乏理论支持必然走不远，所以相关领域亟待学术跟进。\n2. 监管问题。以区块链这种去中心化技术搭建的交易平台，在交易过程中，参与者的身份都是匿名的，这就和传统的交易平台完全不同了，传统的监管方式也无法再使用。因此，目前比特币的交易市场中充斥着洗钱、黑市交易的犯罪活动，这些行为如何监管也是需要在未来解决的问题。\n3. 安全问题，这也是区块链迄今为止面临的最重要的问题，如基于PoW共识过程的区块链面临的51%攻击问题，和基于PoS共识过程的区块链面临的N@S攻击问题，更为安全有效的共识机制还需要人们的研究和设计。\n4. 效率。目前完全同步自创世区块至今的区块数据需要大于60gb的存储空间，而这个数字还在持续增加中，即使是部分节点采用轻量化方案，还是不能完全解决此问题。同时，区块链的交易效率非常低，比特币区块链目前每秒仅能处理七笔交易，这就限制了区块链在大多数金融系统高额交易场景中的应用。最后，它的交易确认时间一般为十分钟左右（区块的生成时间），这在小额交易和时间敏感交易中是不可忍受的。\n\n区块链的技术应用可分为三个阶段：\n\n- 区块链1.0模式：以可编程数字加密货币体系为主要特征。加密货币以比特币、莱特币为代表，具有支付、流通的货币职能。\n- 区块链2.0模式：以可编程金融系统为主要特征。是对金融领域的使用场景和流程进行梳理、优化的应用阶段，以以太坊、瑞波币等为代表的智能合约在这一阶段。\n- 区块链3.0模式：以可编程社会为主要特征，是区块链技术在社会各个领域下的应用场景实现。\n\n需要注意的是，这三个模式并不是演进式发展的，而是并行发展的，在区块链2.0乃至3.0已开始发展的背景下，区块链1.0模式的数字加密货币体系实际上仍远未成熟，还有很长的路要走。\n\n目前部分区块链的项目已初步有了一些简单的应用场景，如通过以太坊网络、BTS平台等发行一些基于区块链技术的项目，但是数量还远远不够，覆盖的应用方向也很少。可以说人们通过比特币认识了区块链，但是区块链技术不仅能够应用于数字加密货币领域，它在数据存储、鉴证，金融交易，资产管理和选举投票等方面都有广大的应用前景。总的来说，区块链技术目前还在积累阶段，它的潜力是巨大的，也许，在未来它不仅能改变我们的交易方式，还能深入的影响我们社会的方方面面，甚至，改变整个社会。","tags":["区块链"]},{"title":"leetcode 765+778 题解","url":"/2018/09/19/leetcode765+778/","content":"\n\n\n这周因为两道题目都只想到了一种解法，所以写在一起。\n\n\n\n## 1. Swim In Rising Water\n\nOn an N x N `grid`, each square `grid[i][j]` represents the elevation at that point `(i,j)`.\n\nNow rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\nYou start at the top left square `(0, 0)`. What is the least time until you can reach the bottom right square `(N-1, N-1)`?\n\n**Example 1:**\n\n```\nInput: [[0,2],[1,3]]\nOutput: 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\n\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n```\n\n**Example 2:**\n\n```\nInput: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\nOutput: 16\nExplanation:\n 0  1  2  3  4\n24 23 22 21  5\n12 13 14 15 16\n11 17 18 19 20\n10  9  8  7  6\n\nThe final route is marked in bold.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n```\n\n**Note:**\n\n1. `2 <= N <= 50`.\n2. grid[i][j] is a permutation of [0, ..., N*N - 1].\n\n\n\n### 解法\n\n这道题的意思是，在t时刻，海拔为t，而n*n的二维矩阵的每个数值都代表了一处的海拔，从一点游到另一点的条件是两处的海拔（值）都大于等于t，要求求出从（0，0）到（n-1，n-1）的最小时间。也就是一个搜索节点的问题，可以用bfs即广度优先搜索的思路来做。\n\n在寻找足够大的t时，我用二分法来实现，这样又可以节约不少时间：\n\n```c++\nint swimInWater(vector<vector<int>>& grid) {\n    int n = grid.size(), st = grid[0][0], ed = n * n - 1, t = 0;\n    while(st < ed){\n        t = (st + ed) / 2;\n        if(swim(grid, t)){\t//判断t时能否到达终点\n            ed = t;\n        }\n        else st = t + (st + ed) % 2;\n    }\n    return st;\n}\n```\n\n真正的实现函数里，bfs用一个queue来实现，还要一个二维vector来记录已经到过的节点。然后就是每次把和节点相邻的未经过的节点（且是数值小于等于t的）加入bfs，并把现有节点pop出去，看能否在bfs为空之前找到终点。\n\n```c++\nbool swim(vector<vector<int>>& grid, int t){\n    int n = grid.size();\n    queue<pair<int, int>> bfs;\n    vector<vector<int>> visited(n, vector<int>(n));\n    int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\t//右左下上\n    bfs.emplace(0, 0);\n    visited[0][0] = 1;\n    while(bfs.size()){\n        int x = bfs.front().first, y = bfs.front().second;\n        bfs.pop();\n        if(grid[x][y] <= t){\n            if(x == n - 1 && y == n - 1) return true;\n            for(auto d : dir){\n                int xs = x + d[0], ys = y + d[1];\n                if(xs >= 0 && xs < n && ys >= 0 && ys < n && !visited[xs][ys]){\t//判断边界\n                    visited[xs][ys] = 1;\n                    bfs.emplace(xs, ys);\n                }\n            }\n        }\n    }\n    return false;\n}\n```\n\n这样就完成了这一道题。\n\n\n\n## 2. Couples Holding Hands\n\nN couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A *swap* consists of choosing **any** two people, then they stand up and switch seats.\n\nThe people and seats are represented by an integer from `0` to `2N-1`, the couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2N-2, 2N-1)`.\n\nThe couples' initial seating is given by `row[i]` being the value of the person who is initially sitting in the i-th seat.\n\n**Example 1:**\n\n```\nInput: row = [0, 2, 1, 3]\nOutput: 1\nExplanation: We only need to swap the second (row[1]) and third (row[2]) person.\n```\n\n\n\n**Example 2:**\n\n```\nInput: row = [3, 2, 0, 1]\nOutput: 0\nExplanation: All couples are already seated side by side.\n```\n\n\n\n**Note:**\n\n1. `len(row)` is even and in the range of `[4, 60]`.\n2. `row` is guaranteed to be a permutation of `0...len(row)-1`.\n\n\n\n### 解法（伪）\n\n在这道题目中，有许多对couple，他们是(0, 1), (2, 3), ..., (2n-2, 2n-1)。现在它们的顺序被打乱了，而你可以随即调换元素的位置，你需要找到调换次数最少的方案。\n\n我的做法是简单的在判断两个元素不是一对couple后，往后查找它的couple并替换，同时调换次数增加一次。\n\n```c++\nint minSwapsCouples(vector<int>& row) {\n    int swap = 0;\n    for(int i = 0; i < row.size() - 1; i += 2){\n        if(row[i] % 2){\n            if(row[i + 1] != row[i] - 1){\n                swap++;\n                for(int j = i + 2; j < row.size(); j++){\n                    if(row[j] == row[i] - 1){\n                        int temp = row[j];\n                        row[j] = row[i + 1];\n                        row[i + 1] = temp;\n                        break;\n                    }\n                }\n            }\n        }\n        else{\n            if(row[i + 1] != row[i] + 1){\n                swap++;\n                for(int j = i + 2; j < row.size(); j++){\n                    if(row[j] == row[i] + 1){\n                        int temp = row[j];\n                        row[j] = row[i + 1];\n                        row[i + 1] = temp;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return swap;\n}\n```\n\n你以为这样就结束了吗？\n\n\n\n### cyclic swapping\n\n上面的解法是在循环中嵌套一个循环，效果显然是不行的，通过leetcode的discuss，我学到了一种更为优秀的解法：cyclic swapping。\n\n这个解法的精华在于：`i == ptn[pos[ptn[row[i]]]]`，乍一看确实毫无头绪，但要首先了解两个额外设置的数组`ptn`和`pos`：\n\n1. `ptn[i]`指的是标签i的couple的值（i可以是位置也可以是具体的值）—— 若i为偶数，`ptn[i] = i + 1`，若i为奇数，`ptn[i] = i - 1`。\n2. `pos[i]`指的是标签i在row数组（也就是给定的随机数组）中的index —— `row[pos[i]] == i`。\n\n这样一来，`i == ptn[pos[ptn[row[i]]]]`的意思就是：\n\n1. 在位置i上的元素有值`row[i]`，我们想把它放在它couple的旁边。\n2. 首先找到它的couple的值，也就是`ptn[row[i]]`。\n3. 接着找到这个couple的位置，也就是`pos[ptn[row[i]]]`。\n4. 最后找到这个位置旁的位置，也就是`ptn[pos[ptn[row[i]]]]`。\n\n接着就可以进行调换了：\n\n```c++\nint minSwapsCouples(vector<int>& row) {\n    int res = 0, N = row.size();\n    vector<int> ptn(N, 0);\n    vector<int> pos(N, 0);\n    for (int i = 0; i < N; i++) {\n        ptn[i] = (i % 2 == 0 ? i + 1 : i - 1);\n        pos[row[i]] = i;\n    }//初始化\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = ptn[pos[ptn[row[i]]]]; i != j; j = ptn[pos[ptn[row[i]]]]) {\n            swap(row[i], row[j]);\n            swap(pos[row[i]], pos[row[j]]);\n            res++;\t//调换次数\n        }\t//这里的循环实际上只是完成一个位置的调换，如果这里的循环多于一次，后面的循环次数会减少\n    }\n        \n    return res;\n}\n```\n\n\n\n\n\n\n","tags":["算法"]},{"title":"leetcode 240 二维矩阵查值 题解","url":"/2018/09/13/leetcode240/","content":"\n\n\n## 题目\n\nWrite an efficient algorithm that searches for a value in an *m* x *n* matrix. This matrix has the following properties:\n\n- Integers in each row are sorted in ascending from left to right.\n- Integers in each column are sorted in ascending from top to bottom.\n\n**Example:**\n\nConsider the following matrix:\n\n```\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n```\n\nGiven target = `5`, return `true`.\n\nGiven target = `20`, return `false`.\n\n\n\n### 解法一\n\n拿到题目一看是查询类的，先暴力解了再说，解法就是两层循环遍历找到值。实现如下：\n\n```c++\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    if(matrix.empty() || matrix[0].empty()) return false;\n    for(int i = 0; i < matrix.size(); i++){\n        for(int j = 0; j < matrix[i].size(); j++){\n            if(matrix[i][j] == target){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n容易看出，这样做的复杂度达到了O(m*n)（m、n对应矩阵的行和列），肯定是不能够让人满意的。\n\n\n\n### 解法二\n\n接下来有哪些地方可以改进的呢？注意这个二维矩阵，暴力求解的时候对每一行是直接顺序扫描，那么这里可以改成对一行进行二分查找，这样一来复杂度可以减少到O(m*logn)，实现如下：\n\n```c++\nbool bisearch(vector<int>& line, int head, int tail, int target){\n    int mid = line[(head + tail) / 2];\n    if(head == tail){\n        return mid == target;\n    }\n    if(mid == target){\n        return true;\n    }\n    if(mid < target){\n        return bisearch(line, (head + tail) / 2 + 1, tail, target);\n    }\n    else{\n        return bisearch(line, head, (head + tail) / 2, target);\n    }\n}\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    if(matrix.empty() || matrix[0].empty()) return false;\n    for(int i = 0; i < matrix.size(); i++){\n        if(matrix[i].size() == 1 && matrix[i][0] == target){\n            return true;\n        }\n        else{\n            if(target > matrix[i][matrix[i].size() - 1]) continue;\n            if(target < matrix[i][0]) return false;\n            if(bisearch(matrix[i], 0, matrix[i].size() - 1, target)){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n\n\n### 解法三\n\n按照上一个解法提交后我发现成绩还是不尽人意（运行时间在所有成功提交中在中间的位置），那么还能怎么改进呢？思考了许久后，我发现是自己一开始就陷入思维定势了，因为这道题类型属于divide and conquer，所以就一直想着二分，其实并不一定要这么做。\n\n重点是要分析透彻这个矩阵的特点，它的每一行、列的元素都是按从小到大的顺序排列好的，所以每个元素的左边元素都比它小，下面元素都比它大，那么只需要从第一行最右元素开始比较，若比target小就向下移动一位（这一行剩下的不需要查找了），若比target大就向左移动一位，这样若矩阵中存在target那么肯定能够找到。其实从最后一行第一个元素开始也可以，原理是一样的。\n\n实现如下：\n\n```c++\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    if(matrix.empty() || matrix[0].empty()) return false;\n    int i = 0, j = matrix[0].size() - 1;\n    while(j >= 0 && i < matrix.size()){\n        if(matrix[i][j] == target){\n            return true;\n        }\n        else if(matrix[i][j] > target){\n            j--;\n        }\n        else{\n            i++;\n        }\n    }\n    return false;\n}\n```\n\n值得一提的是，这样完成的复杂度最差情况下为O(m+n)。\n\n\n\n","tags":["算法"]},{"title":"Win10环境下安装配置VirtualBox，搭建CentOS私有云","url":"/2018/09/09/vbox-cfg/","content":"\n\n\n友情链接：\n\n1. [Win10环境下搭建Ubuntu私有云](https://palette25.github.io/2018/09/08/Serive-Computing-Install-Personal-Cloud/)\n2. [MAC环境下搭建Ubuntu私有云](https://blog.chenmt.science/2018/09/09/77/)\n\n（同队队员的博客，给有需要在windows、mac环境下搭建Ubuntu虚拟机的同学）\n\n\n\n## 准备工作\n\n1. 安装VirtualBox，根据自己的需要下载相应的host版本，在这里我下载的是VirtualBox 5.2.18的Windows host版，下载地址：[官网](https://www.virtualbox.org/wiki/Downloads)\n2. 安装Git客户端（git bash），下载地址：[官网](https://git-scm.com/downloads/)\n3. 下载Linux发行版镜像，可以选择在阿里云[opsx](https://opsx.alibaba.com/mirror)进行下载，在这里我选择的是CentOS7镜像进行下载。\n\n\n\n## 配置VirtualBox\n\n在创建安装虚拟机之前，要先配置虚拟机的存储位置，避免占用不必要的空间。\n\n- VirtualBox菜单：管理 → 全局设定 → 常规 → 默认虚拟电脑位置\n\n之后要创建虚拟机内部虚拟网络，是将来用来测试虚拟机与主机间通讯时要用到的。\n\n- VirtualBox菜单：管理 → 主机网络管理器\n\n将网卡改为手动配置，自行修改Ipv4地址，注意这个地址是作为虚拟内部网络host的地址，后续虚拟机的ip地址不能与之相同。\n\n配置界面：\n\n![配置界面](vbox-cfg/1.png)\n\n配置网络完成后，在主机windows命令行输入ipconfig，可以看到我们创建的网卡的信息。\n\n![网卡信息](vbox-cfg/2.png)\n\n\n\n## 配置CentOS虚拟机\n\n首先用vbox创建一个64 bit虚拟机，命名为centos-base，以便与后面另外创建的虚拟机区分。因为对于这个虚拟机计划只使用命令行操作，所以CPU、内存、显存都采用默认配置就可以，存储设置为30G，避免以后扩展麻烦。\n\n比较重要的是网络的配置：\n\n- 设置 → 网络\n\n第一块网卡设置为NAT（不用调整），这块网卡负责访问外网（通过宿主机）。第二块网卡连接方式：Host-Only，接口为之前创建的虚拟网卡VirtualBox Host-Only Ethernet Adapter #2，这块网卡负责进行虚拟网络连接。\n\n之后导入之前下载的iso文件进行系统安装，完成后进入系统。\n\n进入系统后，第一件事要升级OS系统内核：\n\n- 首先获取wget，`yum install wget`\n\n- 系统自带的源可能比较慢，可以换成163或阿里云的源，这里选择[163源](http://mirrors.163.com/.help/centos.html)进行更换：\n\n  - 首先备份/etc/yum.repos.d/CentOS-Base.repo\n\n    `mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup`\n\n  - 下载对应版本repo文件（这里为CentOS7），并放入/etc/yum.repos.d\n\n    `wget http://mirrors.163.com/.help/CentOS7-Base-163.repo `\n\n  - 运行以下命令生成缓存\n\n    `yum clean all`\n\n    `yum makecache`\n\n- 最后 `yum update`\n\n接着检查网卡配置，命令行输入nmtui，出现配置网卡的界面：\n\n![配置网卡](vbox-cfg/3.png)\n\n进入Edit之后可以看到有enp0s8、enp0s3两个以太网连接，分别对应刚才的Host-Only和NAT。对于enp0s3不用如何调整，只需要在enp0s8的edit界面设置ipv4地址：\n\n![enp0s8](vbox-cfg/4.png)\n\n设置好了不要忘记在activate界面手动激活网卡，因为这里默认开机时不会启动网卡。当然，也可以设置它开机时自动启动。找到网卡的配置文件（在/etc/sysconfig/network-scripts中），将ifcfg-enp0s8和ifcfg-enp0s3（名称对应你的网卡名称）中的ONBOOT选项都改为true，这样就能开机自启了。\n\n接下来尝试ping外网与内网：\n\n![fail](vbox-cfg/5.png)\n\n咦，为什么内网无法ping到？网卡的设置应该是没有问题的，同时我试了一下在windows这边命令行ping 192.168.106.50，也就是虚拟机地址，是没有问题的，说明应该是有一个协议使得连接只能是单向的了，那就应该是windows防火墙的问题了，win10防火墙有三种：域网络、专用网络和公共网络。关闭win10的专用网络防火墙后，果然可以了：\n\n![ok](vbox-cfg/6.png)\n\n下面开始配置第二个CentOS虚拟机，这个虚拟机只需要对centos-base进行复制就可以了，这里把新的虚拟机命名为centos-client，注意复制选项，必须选择重新初始化所有网卡的MAC地址，不然后面无法测试虚拟机之间的通信（地址相同）。最后选择**链接复制**，此时新虚拟机的虚拟硬盘是绑定到原虚拟机的虚拟硬盘的，这样虚拟机创建的就很快。\n\n同样，在第二个虚拟机中，用nmtui配置主机名与第二块网卡的地址，并测试能否ping通，测试结果都很正常。\n\n在这个虚拟机中打算使用centos 桌面，故分配给它的CPU、内存与显存都要调高一些，并使用`yum groupinstall \"GNOME Desktop\"`来安装桌面，安装成功后，设置启动目标为桌面：`ln -sf /lib/systemd/system/runlevel5.target /etc/systemd/system/default.target`，再重启，就可以看到centos桌面了：\n\n![centos](vbox-cfg/7.png)\n\n\n\n## ssh与远程桌面访问\n\n既然是建立私有云，用ssh和远程桌面访问是必不可少的。而要使用这两个工具也需要做一些工作。\n\n首先对于ssh：\n\n- 确保CentOS7安装了openssh-server，在终端输入`yum list installed | grep openssh-server`\n\n- 如果显示没有安装，就输入`yum install openssh-server`来安装\n\n- 有了openssh-server后，找到/etc/ssh/目录下的sshd_config文件并用编辑器打开，将Port、ListenAddress前的＃号去除，并把PermitRootLogin和PasswordAuthentication设为yes\n\n  ![8](vbox-cfg/8.png)\n\n  ![9](vbox-cfg/9.png)\n\n  ![10](vbox-cfg/10.png)\n\n测试ssh连接成功：\n\n![ssh2](vbox-cfg/11.png)\n\n接下来是远程桌面访问：\n\n- 首先要安装VirtualBox远程显示系统的扩展包[Oracle VM VirtualBox Extension pack](https://www.virtualbox.org/wiki/Downloads)，它提供一系列的功能支持：USB 2.0，intel网卡的PXE启动与VirtualBox远程显示系统。安装完成后，重启宿主机。\n\n- 设置虚拟机访问端口：点击虚拟机设置 → 显示 → 远程桌面 → 启用服务器并设置连接端口，注意连接时用的是宿主机的IP地址加上子机的端口（也就是192.168.106.1:（设置的端口）），每台虚拟机必须拥有唯一的RDP访问端口。\n\n- 最后，用Windows的Remote Desktop Connection（远程桌面连接）终端进行远程桌面访问（注意先启动虚拟机）\n\n  ![rdc](vbox-cfg/12..png)\n\n  ![ssh2](vbox-cfg/13.png)\n\n\n\n这样以来，私有云就搭建好了，可以开始愉快的玩耍了~\n\n\n\n\n\n\n","tags":["服务计算"]},{"title":"CCF 201803-2 碰撞的小球 题解","url":"/2018/09/06/CCF201803-2/","content":"\n最近准备参加CCF认证，刷一下这里的题目。\n\n\n\n## 题目\n\n**问题描述**\n\n数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。\n\n当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。\n\n当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。\n\n现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。\n\n\n\n**提示**\n\n因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。\n\n同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。\n\n\n\n**输入格式**\n\n输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。\n\n第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。\n\n\n\n**输出格式**\n\n输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。\n\n\n\n**Example :**\n\n```\nInput: 3 10 5\n\t   4 6 8\nOutput: 7 9 9\n```\n\n\n\n## 题解\n\n一开始可能有点懵，不过想到每个小球都有自己的运动方向、位置，就可以联想到建立对象来解题。\n\n```c++\nint length;\t//每个球都再判断是否碰墙的时候都需要这个值\nclass Ball{\n    public:\n        Ball(){\n            direction = 1;\n            this->pos = 0;\n        }\n        int getpos(){\n            return pos;\n        }\n        void initpos(int pos){\n            this->pos = pos;\n        }\n        void move(){\n            pos = (direction) ? pos + 1 : pos - 1;\n        }\n        bool againstwall(){\n            return (pos == 0 || pos == length) ? true : false;\n        }\n        void turn(){\n            direction = (direction == 1) ? 0 : 1;\n        }\n    private:\n        int pos;\n        int direction;\n};\n```\n\n\n\n类建好后，解题就比较简单了。\n\n```c++\nint main(){\n    int numofball, time;\n    cin >> numofball >> length >> time;\n    Ball *balls = new Ball[numofball];\n    for(int i = 0; i < numofball; i++){\n        int pos;\n        cin >> pos;\n        balls[i].initpos(pos);\n    }\n    while(time--){\n        for(int i = 0; i < numofball; i++){\n            balls[i].move();\n            if(balls[i].againstwall()){\n                balls[i].turn();\n            }\n        }\n        for(int i = 0; i < numofball - 1; i++){\n            for(int j = i + 1; j < numofball; j++){\n                if(balls[i].getpos() == balls[j].getpos()){\n                    balls[i].turn();\n                    balls[j].turn();\n                    break;\n                }\n            }\n        }\n    }\n    for(int i = 0; i < numofball; i++){\n        cout << balls[i].getpos() << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n```\n\n\n\n这里球跟球之间的碰撞处理的比较简单粗暴，不过暂时也没有想到更好的方法（其实是懒），就先这样吧。","tags":["算法"]},{"title":"leetcode 05 最长子回文串 题解","url":"/2018/09/05/leetcode05/","content":"\n## 题目\n\nGiven a string **s**, find the longest palindromic substring in **s**. You may assume that the maximum length of **s** is 1000.\n\n**Example 1:**\n\n```\nInput: \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer.\n```\n\n  \n\n**Example 2:**\n\n```\nInput: \"cbbd\"\nOutput: \"bb\"\n```\n\n\n\n### 解法一\n\n首先想到的当然是暴力解法了，对字符串的每一子字符串都进行是否为回文字符串的判定。所谓回文字符串就是正反都一样的字符串。\n\n解法如下：\n\n```c++\nbool isPalindrome(string s){\n    for(int i = 0; i < s.length() / 2; i++){\n        if(s[i] != s[s.length() - 1 - i]){\n            return false;\n        }\n    }\n    return true;\n}\nstring longestPalindrome(string s) {\n    int maxlength = 1;\n    string longeststr = s.substr(0, 1);\n    for(int i = 0; i < s.length(); i++){\n        if(maxlength >= s.length() - i) return longeststr;\n        for(int j = maxlength + 1; j <= s.length() - i; j++){\n            if(isPalindrome(s.substr(i, j))){\n                if(j > maxlength){\n                    longeststr = s.substr(i, j);\n                    maxlength = j;\n                }\n            }\n        }\n    }\n    return longeststr;\n}\n```\n\n这里也对暴力解法进行了一些优化，比如在外层循环时，如果已经得到的最长回文字符串的长度大于此时要处理的子字符串的长度就直接返回；内存循环直接从此时得到的最长回文字符串的长度+1开始。然而，可以想见的是，效果依然是很差的。\n\n\n\n### 解法二\n\n之后思考许久也没有找到更好的算法，遂查看leetcode的提示，提示是说在寻找新的更长的回文字符串时，要用到已计算的回文字符串。这样一来可以减少判断回文字符串的时间。\n\n解法如下：\n\n```c++\nstring longestPalindrome(string s) {\n    int minstart = 0, maxlength = 1;\n    for(int i = 0; i < s.size(); i++){\n        int sub = i, add = i;\n        while(add < s.size() - 1 && s[add + 1] == s[add]){\n            add++;\n        }\n        while(sub > 0 && add < s.size() - 1 && s[add + 1] == s[sub - 1]){\n            add++;\n            sub--;\n        }\n        int newlength = add - sub + 1;\n        if(newlength > maxlength){\n            minstart = sub;\n            maxlength = newlength;\n        }\n    }\n    return s.substr(minstart, maxlength);\n}\n```\n\n这个解法是每次以循环位置i为中心，向两端扩展找到最长的回文字符串，在判断是否为回文字符串时，实际上只用判断s[add + 1] == s[sub - 1]，也就是这一步时间复杂度仅为O(1)，这样就大幅缩短了算法运行的时间。\n\n","tags":["算法"]}]